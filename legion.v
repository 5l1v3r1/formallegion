(* generated by Ott 0.25 from: legion.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.


Require Import Nat.
Require Import ListSet.
Import ListNotations.

Definition termvar := nat. (*r term variable *)
Lemma eq_termvar: forall (x y : termvar), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_termvar : ott_coq_equality.
Definition index := nat.

Inductive r : Set := 
 | r_Null : r
 | r_NotNull : r.

Inductive phi : Set := 
 | p_Reads (r5:r)
 | p_Writes (r5:r)
 | p_Reduces (r5:r).

Inductive q : Set := 
 | q_Atomic (r5:r)
 | q_Simultaneous (r5:r).

Inductive list_phi : Set := 
 | Nil_list_phi : list_phi
 | Cons_list_phi (_:phi) (_:list_phi).

Inductive list_q : Set := 
 | Nil_list_q : list_q
 | Cons_list_q (_:q) (_:list_q).

Inductive rho : Set := 
.

Inductive list_r : Set := 
 | Nil_list_r : list_r
 | Cons_list_r (_:r) (_:list_r).

Inductive P : Set := 
 | P_Priv (_:list_phi)
 | P_EmptyPriv : P.

Inductive Q : Set := 
 | Q_CoherenceModes (_:list_q).

Inductive list_r_r : Set := 
 | Nil_list_r_r : list_r_r
 | Cons_list_r_r (_:r) (_:r) (_:list_r_r).

Inductive l : Set := 
 | ML_NilLoc : l.

Inductive list_rho : Set := 
 | Nil_list_rho : list_rho
 | Cons_list_rho (_:rho) (_:list_rho).

Inductive rr : Set := 
 | rr_Rlist (_:list_r).

Inductive iv : Set := 
.

Inductive K : Set := 
 | K_Null : K.

Inductive bv : Set := 
 | bv_True : bv (*r constant true *)
 | bv_False : bv (*r constant false *).

Inductive T : Set := 
 | T_Num : T
 | T_Va : T
 | T_Tuple (_:list_T)
 | T_PointerOne (T5:T) (r5:r)
 | T_Pointer (T5:T) (_:list_r)
 | T_TypeList (T5:T) (_:list_r)
 | T_TypeRepl (T5:T) (_:list_r_r)
 | T_RegionColoring (r5:r)
 | T_Functions (_:list_r) (_:list_T) (P5:P) (Q5:Q)
with list_T : Set := 
 | Nil_list_T : list_T
 | Cons_list_T (_:T) (_:list_T).


Inductive H : Set := 
 | H_Hl (H5:H) (l5:l).

Inductive id : Set := 
.
Inductive privs : Set := 
| priv_excl
| priv_atomic.


Inductive ee : Set := 
 | ee_Elist (_:list_e)
with e : Set := 
 | E_Va (x:termvar)
 | E_New (T5:T) (r5:r)
 | E_NullFn (T5:T) (r5:r)
 | E_isNull (e5:e)
 | E_UpRegion (e5:e) (_:list_r)
 | E_DownRegion (e5:e) (_:list_r)
 | E_Read (e5:e)
 | E_Write (e1:e) (e2:e)
 | E_Reduce (id5:id) (e1:e) (e2:e)
 | E_Reduceid (l5:l) (e1:e) (e2:e) (e3:e)
 | E_NewColor (r5:r)
 | E_Color (e1:e) (e2:e) (e3:e)
 | E_IntOp (e1:e) (e2:e)
 | E_Comp (e1:e) (e2:e)
 | E_Let (id5:id) (T5:T) (e1:e) (e2:e)
 | E_If (e1:e) (e2:e) (e3:e) (*r conditional *)
 | E_FuncCall (id5:id) (_:list_r) (_:list_e)
 | E_Part (rp:r) (e1:e) (_:list_r) (e2:e)
 | E_Pack (e1:e) (T5:T)
 | E_Unpack (e1:e) (id5:id) (T5:T) (e2:e)
 | E_FuncDef (id5:id) (_:list_r) (_:list_e)
 | E_FuncDefList (_:list_id_rr_ee)
 | E_TypedExpr (e5:e) (T5:T)
 | E_PlaceHolder : e
 | E_Base1 (bv5:bv)
 | E_Base2 (iv5:iv)
 | E_Tuple (v1:e) (v2:e)
 | E_NullLoc : e
 | E_MemoryLoc (l5:l)
 | E_RegRelInst (_:list_rho) (v5:e)
 | E_HeapVal (H5:H)
 | E_Kthing (K5:K)
 | E_True : e (*r constant true *)
 | E_False : e (*r constant false *)
 | E_Zero : e
 | E_Succ (Clobber5:list emem) (iv5:iv)
with list_e : Set := 
 | Nil_list_e : list_e
 | Cons_list_e (_:e) (_:list_e)
with list_id_rr_ee : Set := 
 | Nil_list_id_rr_ee : list_id_rr_ee
 | Cons_list_id_rr_ee (_:id) (_:rr) (_:ee) (_:list_id_rr_ee)
with emem : Set := 
 | em_ReadE (e1:e) (privs5:privs) (e2:e) (e3:e)
 | em_WriteE (e1:e) (privs5:privs) (e2:e) (e3:e)
 | em_ReduceIdE (e1:e) (privs5:privs) (e2:e) (e3:e).


Inductive om : Set := 
 | o_Subregion (r1:r) (r2:r)
 | o_Disjointness (r1:r) (r2:r).

Definition E := (list emem) % type.

Definition Clobber : (list emem) % type.

(* | [] : E
 | E_Append (E5:E) (emem5:emem). *)

Inductive list_e_e : Set := 
 | Nil_list_e_e : list_e_e
 | Cons_list_e_e (_:e) (v:e) (_:list_e_e).

Inductive list_om : Set := 
 | Nil_list_om : list_om
 | Cons_list_om (_:om) (_:list_om).

Inductive list_E : Set := 
 | Nil_list_E : list_E
 | Cons_list_E (_:E) (_:list_E).

Inductive fresh : Set := 
 | ti_TaskNum (iv5:iv).

Inductive M : Set := 
 | M_Null : M
 | M_Qexpr (M5:M) (Q5:Q).

Inductive C : Set := 
.

Inductive list_e_T : Set := 
 | Nil_list_e_T : list_e_T
 | Cons_list_e_T (_:e) (_:T) (_:list_e_T).

Inductive L : Set := 
 | L_Nil : L
 | L_LMapping (L5:L) (_:list_e_e)
 | L_LRepl (L5:L) (e5:e) (id5:id).

Inductive Ost : Set := 
 | Ost_RegionConstraintSt (_:list_om)
 | Ost_EmptyConstraintSt : Ost.

Inductive Omega : Set := 
 | O_RegionConstraint (_:list_om)
 | O_EmptyConstraint : Omega.

Inductive G : Set := 
 | G_Context (_:list_e_T)
 | G_EmptyContext : G.

Inductive Pst : Set := 
 | Pst_PrivSt (_:list_phi)
 | Pst_EmptyPrivSt : Pst.

Inductive rs : Set := 
 | O_Regions (_:list_r)
 | O_EmptyRegion : rs.
Fixpoint map_list_id_rr_ee (A:Set) (f:id->rr->ee->A) (l0:list_id_rr_ee) : list A :=
  match l0 with
  | Nil_list_id_rr_ee => nil
  | Cons_list_id_rr_ee h0 h1 h2 tl_ => cons (f h0 h1 h2) (map_list_id_rr_ee A f tl_)
  end.
Implicit Arguments map_list_id_rr_ee.

Fixpoint make_list_id_rr_ee (l0: list (id * rr * ee)): list_id_rr_ee :=
  match l0 with
  | nil  => Nil_list_id_rr_ee
  | cons (h0,h1,h2) tl_ => Cons_list_id_rr_ee h0 h1 h2 (make_list_id_rr_ee tl_)
  end.

Fixpoint unmake_list_id_rr_ee (l0: list_id_rr_ee): list (id * rr * ee) :=
  match l0 with
  | Nil_list_id_rr_ee => nil
  | Cons_list_id_rr_ee h0 h1 h2 tl_ => cons (h0,h1,h2) (unmake_list_id_rr_ee tl_)
  end.

Fixpoint nth_list_id_rr_ee (n:nat) (l0: list_id_rr_ee) {struct n} : option (id * rr * ee) :=
  match n,l0 with
  | O, Cons_list_id_rr_ee h0 h1 h2 tl_ => Some (h0,h1,h2)
  | O, _ => None
  | S m, Nil_list_id_rr_ee => None
  | S m, Cons_list_id_rr_ee h0 h1 h2 tl_ => nth_list_id_rr_ee m tl_
  end.

Fixpoint app_list_id_rr_ee (l0 m: list_id_rr_ee): list_id_rr_ee :=
  match l0 with
  | Nil_list_id_rr_ee => m
  | Cons_list_id_rr_ee h0 h1 h2 tl_ => Cons_list_id_rr_ee h0 h1 h2 (app_list_id_rr_ee tl_ m)
  end.

Fixpoint map_list_E (A:Set) (f:E->A) (l0:list_E) : list A :=
  match l0 with
  | Nil_list_E => nil
  | Cons_list_E h tl_ => cons (f h) (map_list_E A f tl_)
  end.
Implicit Arguments map_list_E.

Fixpoint make_list_E (l0: list E): list_E :=
  match l0 with
  | nil  => Nil_list_E
  | cons h tl_ => Cons_list_E h (make_list_E tl_)
  end.

Fixpoint unmake_list_E (l0: list_E): list E :=
  match l0 with
  | Nil_list_E => nil
  | Cons_list_E h tl_ => cons h (unmake_list_E tl_)
  end.

Fixpoint nth_list_E (n:nat) (l0: list_E) {struct n} : option E :=
  match n,l0 with
  | O, Cons_list_E h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_E => None
  | S m, Cons_list_E h tl_ => nth_list_E m tl_
  end.

Fixpoint app_list_E (l0 m: list_E): list_E :=
  match l0 with
  | Nil_list_E => m
  | Cons_list_E h tl_ => Cons_list_E h (app_list_E tl_ m)
  end.

Fixpoint map_list_r_r (A:Set) (f:r->r->A) (l0:list_r_r) : list A :=
  match l0 with
  | Nil_list_r_r => nil
  | Cons_list_r_r h0 h1 tl_ => cons (f h0 h1) (map_list_r_r A f tl_)
  end.
Implicit Arguments map_list_r_r.

Fixpoint make_list_r_r (l0: list (r * r)): list_r_r :=
  match l0 with
  | nil  => Nil_list_r_r
  | cons (h0,h1) tl_ => Cons_list_r_r h0 h1 (make_list_r_r tl_)
  end.

Fixpoint unmake_list_r_r (l0: list_r_r): list (r * r) :=
  match l0 with
  | Nil_list_r_r => nil
  | Cons_list_r_r h0 h1 tl_ => cons (h0,h1) (unmake_list_r_r tl_)
  end.

Fixpoint nth_list_r_r (n:nat) (l0: list_r_r) {struct n} : option (r * r) :=
  match n,l0 with
  | O, Cons_list_r_r h0 h1 tl_ => Some (h0,h1)
  | O, _ => None
  | S m, Nil_list_r_r => None
  | S m, Cons_list_r_r h0 h1 tl_ => nth_list_r_r m tl_
  end.

Fixpoint app_list_r_r (l0 m: list_r_r): list_r_r :=
  match l0 with
  | Nil_list_r_r => m
  | Cons_list_r_r h0 h1 tl_ => Cons_list_r_r h0 h1 (app_list_r_r tl_ m)
  end.

Fixpoint map_list_T (A:Set) (f:T->A) (l0:list_T) : list A :=
  match l0 with
  | Nil_list_T => nil
  | Cons_list_T h tl_ => cons (f h) (map_list_T A f tl_)
  end.
Implicit Arguments map_list_T.

Fixpoint make_list_T (l0: list T): list_T :=
  match l0 with
  | nil  => Nil_list_T
  | cons h tl_ => Cons_list_T h (make_list_T tl_)
  end.

Fixpoint unmake_list_T (l0: list_T): list T :=
  match l0 with
  | Nil_list_T => nil
  | Cons_list_T h tl_ => cons h (unmake_list_T tl_)
  end.

Fixpoint nth_list_T (n:nat) (l0: list_T) {struct n} : option T :=
  match n,l0 with
  | O, Cons_list_T h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_T => None
  | S m, Cons_list_T h tl_ => nth_list_T m tl_
  end.

Fixpoint app_list_T (l0 m: list_T): list_T :=
  match l0 with
  | Nil_list_T => m
  | Cons_list_T h tl_ => Cons_list_T h (app_list_T tl_ m)
  end.

Fixpoint map_list_e (A:Set) (f:e->A) (l0:list_e) : list A :=
  match l0 with
  | Nil_list_e => nil
  | Cons_list_e h tl_ => cons (f h) (map_list_e A f tl_)
  end.
Implicit Arguments map_list_e.

Fixpoint make_list_e (l0: list e): list_e :=
  match l0 with
  | nil  => Nil_list_e
  | cons h tl_ => Cons_list_e h (make_list_e tl_)
  end.

Fixpoint unmake_list_e (l0: list_e): list e :=
  match l0 with
  | Nil_list_e => nil
  | Cons_list_e h tl_ => cons h (unmake_list_e tl_)
  end.

Fixpoint nth_list_e (n:nat) (l0: list_e) {struct n} : option e :=
  match n,l0 with
  | O, Cons_list_e h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_e => None
  | S m, Cons_list_e h tl_ => nth_list_e m tl_
  end.

Fixpoint app_list_e (l0 m: list_e): list_e :=
  match l0 with
  | Nil_list_e => m
  | Cons_list_e h tl_ => Cons_list_e h (app_list_e tl_ m)
  end.

Fixpoint map_list_rho (A:Set) (f:rho->A) (l0:list_rho) : list A :=
  match l0 with
  | Nil_list_rho => nil
  | Cons_list_rho h tl_ => cons (f h) (map_list_rho A f tl_)
  end.
Implicit Arguments map_list_rho.

Fixpoint make_list_rho (l0: list rho): list_rho :=
  match l0 with
  | nil  => Nil_list_rho
  | cons h tl_ => Cons_list_rho h (make_list_rho tl_)
  end.

Fixpoint unmake_list_rho (l0: list_rho): list rho :=
  match l0 with
  | Nil_list_rho => nil
  | Cons_list_rho h tl_ => cons h (unmake_list_rho tl_)
  end.

Fixpoint nth_list_rho (n:nat) (l0: list_rho) {struct n} : option rho :=
  match n,l0 with
  | O, Cons_list_rho h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_rho => None
  | S m, Cons_list_rho h tl_ => nth_list_rho m tl_
  end.

Fixpoint app_list_rho (l0 m: list_rho): list_rho :=
  match l0 with
  | Nil_list_rho => m
  | Cons_list_rho h tl_ => Cons_list_rho h (app_list_rho tl_ m)
  end.

Fixpoint map_list_e_e (A:Set) (f:e->e->A) (l0:list_e_e) : list A :=
  match l0 with
  | Nil_list_e_e => nil
  | Cons_list_e_e h0 h1 tl_ => cons (f h0 h1) (map_list_e_e A f tl_)
  end.
Implicit Arguments map_list_e_e.

Fixpoint make_list_e_e (l0: list (e * e)): list_e_e :=
  match l0 with
  | nil  => Nil_list_e_e
  | cons (h0,h1) tl_ => Cons_list_e_e h0 h1 (make_list_e_e tl_)
  end.

Fixpoint unmake_list_e_e (l0: list_e_e): list (e * e) :=
  match l0 with
  | Nil_list_e_e => nil
  | Cons_list_e_e h0 h1 tl_ => cons (h0,h1) (unmake_list_e_e tl_)
  end.

Fixpoint nth_list_e_e (n:nat) (l0: list_e_e) {struct n} : option (e * e) :=
  match n,l0 with
  | O, Cons_list_e_e h0 h1 tl_ => Some (h0,h1)
  | O, _ => None
  | S m, Nil_list_e_e => None
  | S m, Cons_list_e_e h0 h1 tl_ => nth_list_e_e m tl_
  end.

Fixpoint app_list_e_e (l0 m: list_e_e): list_e_e :=
  match l0 with
  | Nil_list_e_e => m
  | Cons_list_e_e h0 h1 tl_ => Cons_list_e_e h0 h1 (app_list_e_e tl_ m)
  end.

Fixpoint map_list_q (A:Set) (f:q->A) (l0:list_q) : list A :=
  match l0 with
  | Nil_list_q => nil
  | Cons_list_q h tl_ => cons (f h) (map_list_q A f tl_)
  end.
Implicit Arguments map_list_q.

Fixpoint make_list_q (l0: list q): list_q :=
  match l0 with
  | nil  => Nil_list_q
  | cons h tl_ => Cons_list_q h (make_list_q tl_)
  end.

Fixpoint unmake_list_q (l0: list_q): list q :=
  match l0 with
  | Nil_list_q => nil
  | Cons_list_q h tl_ => cons h (unmake_list_q tl_)
  end.

Fixpoint nth_list_q (n:nat) (l0: list_q) {struct n} : option q :=
  match n,l0 with
  | O, Cons_list_q h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_q => None
  | S m, Cons_list_q h tl_ => nth_list_q m tl_
  end.

Fixpoint app_list_q (l0 m: list_q): list_q :=
  match l0 with
  | Nil_list_q => m
  | Cons_list_q h tl_ => Cons_list_q h (app_list_q tl_ m)
  end.

Fixpoint map_list_phi (A:Set) (f:phi->A) (l0:list_phi) : list A :=
  match l0 with
  | Nil_list_phi => nil
  | Cons_list_phi h tl_ => cons (f h) (map_list_phi A f tl_)
  end.
Implicit Arguments map_list_phi.

Fixpoint make_list_phi (l0: list phi): list_phi :=
  match l0 with
  | nil  => Nil_list_phi
  | cons h tl_ => Cons_list_phi h (make_list_phi tl_)
  end.

Fixpoint unmake_list_phi (l0: list_phi): list phi :=
  match l0 with
  | Nil_list_phi => nil
  | Cons_list_phi h tl_ => cons h (unmake_list_phi tl_)
  end.

Fixpoint nth_list_phi (n:nat) (l0: list_phi) {struct n} : option phi :=
  match n,l0 with
  | O, Cons_list_phi h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_phi => None
  | S m, Cons_list_phi h tl_ => nth_list_phi m tl_
  end.

Fixpoint app_list_phi (l0 m: list_phi): list_phi :=
  match l0 with
  | Nil_list_phi => m
  | Cons_list_phi h tl_ => Cons_list_phi h (app_list_phi tl_ m)
  end.

Fixpoint map_list_om (A:Set) (f:om->A) (l0:list_om) : list A :=
  match l0 with
  | Nil_list_om => nil
  | Cons_list_om h tl_ => cons (f h) (map_list_om A f tl_)
  end.
Implicit Arguments map_list_om.

Fixpoint make_list_om (l0: list om): list_om :=
  match l0 with
  | nil  => Nil_list_om
  | cons h tl_ => Cons_list_om h (make_list_om tl_)
  end.

Fixpoint unmake_list_om (l0: list_om): list om :=
  match l0 with
  | Nil_list_om => nil
  | Cons_list_om h tl_ => cons h (unmake_list_om tl_)
  end.

Fixpoint nth_list_om (n:nat) (l0: list_om) {struct n} : option om :=
  match n,l0 with
  | O, Cons_list_om h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_om => None
  | S m, Cons_list_om h tl_ => nth_list_om m tl_
  end.

Fixpoint app_list_om (l0 m: list_om): list_om :=
  match l0 with
  | Nil_list_om => m
  | Cons_list_om h tl_ => Cons_list_om h (app_list_om tl_ m)
  end.

Fixpoint map_list_e_T (A:Set) (f:e->T->A) (l0:list_e_T) : list A :=
  match l0 with
  | Nil_list_e_T => nil
  | Cons_list_e_T h0 h1 tl_ => cons (f h0 h1) (map_list_e_T A f tl_)
  end.
Implicit Arguments map_list_e_T.

Fixpoint make_list_e_T (l0: list (e * T)): list_e_T :=
  match l0 with
  | nil  => Nil_list_e_T
  | cons (h0,h1) tl_ => Cons_list_e_T h0 h1 (make_list_e_T tl_)
  end.

Fixpoint unmake_list_e_T (l0: list_e_T): list (e * T) :=
  match l0 with
  | Nil_list_e_T => nil
  | Cons_list_e_T h0 h1 tl_ => cons (h0,h1) (unmake_list_e_T tl_)
  end.

Fixpoint nth_list_e_T (n:nat) (l0: list_e_T) {struct n} : option (e * T) :=
  match n,l0 with
  | O, Cons_list_e_T h0 h1 tl_ => Some (h0,h1)
  | O, _ => None
  | S m, Nil_list_e_T => None
  | S m, Cons_list_e_T h0 h1 tl_ => nth_list_e_T m tl_
  end.

Fixpoint app_list_e_T (l0 m: list_e_T): list_e_T :=
  match l0 with
  | Nil_list_e_T => m
  | Cons_list_e_T h0 h1 tl_ => Cons_list_e_T h0 h1 (app_list_e_T tl_ m)
  end.

Fixpoint map_list_r (A:Set) (f:r->A) (l0:list_r) : list A :=
  match l0 with
  | Nil_list_r => nil
  | Cons_list_r h tl_ => cons (f h) (map_list_r A f tl_)
  end.
Implicit Arguments map_list_r.

Fixpoint make_list_r (l0: list r): list_r :=
  match l0 with
  | nil  => Nil_list_r
  | cons h tl_ => Cons_list_r h (make_list_r tl_)
  end.

Fixpoint unmake_list_r (l0: list_r): list r :=
  match l0 with
  | Nil_list_r => nil
  | Cons_list_r h tl_ => cons h (unmake_list_r tl_)
  end.

Fixpoint nth_list_r (n:nat) (l0: list_r) {struct n} : option r :=
  match n,l0 with
  | O, Cons_list_r h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_r => None
  | S m, Cons_list_r h tl_ => nth_list_r m tl_
  end.

Fixpoint app_list_r (l0 m: list_r): list_r :=
  match l0 with
  | Nil_list_r => m
  | Cons_list_r h tl_ => Cons_list_r h (app_list_r tl_ m)
  end.


(** subrules *)
Fixpoint is_v_of_rho_list (l:list_rho) : Prop :=
  match l with
  | Nil_list_rho => True
  | Cons_list_rho rho_ rho_list_ => True /\ (is_v_of_rho_list rho_list_)
end.

Fixpoint is_e_of_r_list (l:list_r) : Prop :=
  match l with
  | Nil_list_r => True
  | Cons_list_r r_ r_list_ => True /\ (is_e_of_r_list r_list_)
end.

Fixpoint is_e_of_rho_list (l:list_rho) : Prop :=
  match l with
  | Nil_list_rho => True
  | Cons_list_rho rho_ rho_list_ => True /\ (is_e_of_rho_list rho_list_)
end.

Fixpoint is_v_of_e (e_6:e) : Prop :=
  match e_6 with
  | (E_Va x) => False
  | (E_New T5 r5) => False
  | (E_NullFn T5 r5) => False
  | (E_isNull e5) => False
  | (E_UpRegion e5 r_list) => False
  | (E_DownRegion e5 r_list) => False
  | (E_Read e5) => False
  | (E_Write e1 e2) => False
  | (E_Reduce id5 e1 e2) => False
  | (E_Reduceid l5 e1 e2 e3) => False
  | (E_NewColor r5) => False
  | (E_Color e1 e2 e3) => False
  | (E_IntOp e1 e2) => False
  | (E_Comp e1 e2) => False
  | (E_Let id5 T5 e1 e2) => False
  | (E_If e1 e2 e3) => False
  | (E_FuncCall id5 r_list e_list) => False
  | (E_Part t101 e1 r_list e2) => False
  | (E_Pack e1 T5) => False
  | (E_Unpack e1 id5 T5 e2) => False
  | (E_FuncDef id5 r_list e_list) => False
  | (E_FuncDefList id_rr_ee_list) => False
  | (E_TypedExpr e5 T5) => False
  | E_PlaceHolder => (True)
  | (E_Base1 bv5) => (True)
  | (E_Base2 iv5) => (True)
  | (E_Tuple v1 v2) => ((is_v_of_e v1) /\ (is_v_of_e v2))
  | E_NullLoc => (True)
  | (E_MemoryLoc l5) => (True)
  | (E_RegRelInst rho_list v5) => (is_v_of_rho_list rho_list /\ (is_v_of_e v5))
  | (E_HeapVal H5) => (True)
  | (E_Kthing K5) => (True)
  | E_True => False
  | E_False => False
  | E_Zero => False
  | (E_Succ Clobber5 iv5) => False
end.

Fixpoint is_ee_of_e_list (l:list_e) : Prop :=
  match l with
  | Nil_list_e => True
  | Cons_list_e e_ e_list_ => (is_e_of_e e_) /\ (is_ee_of_e_list e_list_)
end
with is_ee_of_ee (ee5:ee) : Prop :=
  match ee5 with
  | (ee_Elist e_list) => (is_ee_of_e_list e_list)
end
with is_e_of_id_rr_ee_list (l:list_id_rr_ee) : Prop :=
  match l with
  | Nil_list_id_rr_ee => True
  | Cons_list_id_rr_ee id_ rr_ ee_ id_rr_ee_list_ => (is_ee_of_ee ee_) /\ (is_e_of_id_rr_ee_list id_rr_ee_list_)
end
with is_e_of_e_list (l:list_e) : Prop :=
  match l with
  | Nil_list_e => True
  | Cons_list_e e_ e_list_ => (is_e_of_e e_) /\ (is_e_of_e_list e_list_)
end
with is_e_of_e (e_6:e) : Prop :=
  match e_6 with
  | (E_Va x) => (True)
  | (E_New T5 r5) => (True)
  | (E_NullFn T5 r5) => (True)
  | (E_isNull e5) => ((is_e_of_e e5))
  | (E_UpRegion e5 r_list) => ((is_e_of_e e5) /\ is_e_of_r_list r_list)
  | (E_DownRegion e5 r_list) => ((is_e_of_e e5) /\ is_e_of_r_list r_list)
  | (E_Read e5) => ((is_e_of_e e5))
  | (E_Write e1 e2) => ((is_e_of_e e1) /\ (is_e_of_e e2))
  | (E_Reduce id5 e1 e2) => ((is_e_of_e e1) /\ (is_e_of_e e2))
  | (E_Reduceid l5 e1 e2 e3) => ((is_e_of_e e1) /\ (is_e_of_e e2) /\ (is_e_of_e e3))
  | (E_NewColor r5) => (True)
  | (E_Color e1 e2 e3) => ((is_e_of_e e1) /\ (is_e_of_e e2) /\ (is_e_of_e e3))
  | (E_IntOp e1 e2) => ((is_e_of_e e1) /\ (is_e_of_e e2))
  | (E_Comp e1 e2) => ((is_e_of_e e1) /\ (is_e_of_e e2))
  | (E_Let id5 T5 e1 e2) => ((is_e_of_e e1) /\ (is_e_of_e e2))
  | (E_If e1 e2 e3) => ((is_e_of_e e1) /\ (is_e_of_e e2) /\ (is_e_of_e e3))
  | (E_FuncCall id5 r_list e_list) => (is_e_of_r_list r_list /\ is_e_of_e_list e_list)
  | (E_Part t102 e1 r_list e2) => ((is_e_of_e e1) /\ is_e_of_r_list r_list /\ (is_e_of_e e2))
  | (E_Pack e1 T5) => ((is_e_of_e e1))
  | (E_Unpack e1 id5 T5 e2) => ((is_e_of_e e1) /\ (is_e_of_e e2))
  | (E_FuncDef id5 r_list e_list) => (is_e_of_r_list r_list /\ is_e_of_e_list e_list)
  | (E_FuncDefList id_rr_ee_list) => (is_e_of_id_rr_ee_list id_rr_ee_list)
  | (E_TypedExpr e5 T5) => ((is_e_of_e e5))
  | E_PlaceHolder => (True)
  | (E_Base1 bv5) => (True)
  | (E_Base2 iv5) => (True)
  | (E_Tuple v1 v2) => ((is_v_of_e v1) /\ (is_v_of_e v2))
  | E_NullLoc => (True)
  | (E_MemoryLoc l5) => (True)
  | (E_RegRelInst rho_list v5) => (is_e_of_rho_list rho_list /\ (is_v_of_e v5))
  | (E_HeapVal H5) => (True)
  | (E_Kthing K5) => (True)
  | E_True => (True)
  | E_False => (True)
  | E_Zero => (True)
  | (E_Succ Clobber5 iv5) => (True)
end.

Fixpoint is_G_of_e_T_list (l:list_e_T) : Prop :=
  match l with
  | Nil_list_e_T => True
  | Cons_list_e_T e_ T_ e_T_list_ => (is_e_of_e e_) /\ (is_G_of_e_T_list e_T_list_)
end.

Fixpoint is_L_of_e_e_list (l:list_e_e) : Prop :=
  match l with
  | Nil_list_e_e => True
  | Cons_list_e_e e_ v_ e_v_list_ => (is_e_of_e e_) /\ (is_v_of_e v_) /\ (is_L_of_e_e_list e_v_list_)
end.

Definition is_G_of_G (G5:G) : Prop :=
  match G5 with
  | (G_Context e_T_list) => (is_G_of_e_T_list e_T_list)
  | G_EmptyContext => (True)
end.

Definition is_emem_of_emem (emem5:emem) : Prop :=
  match emem5 with
  | (em_ReadE e1 privs5 e2 e3) => ((is_e_of_e e1) /\ (is_e_of_e e2) /\ (is_e_of_e e3))
  | (em_WriteE e1 privs5 e2 e3) => ((is_e_of_e e1) /\ (is_e_of_e e2) /\ (is_e_of_e e3))
  | (em_ReduceIdE e1 privs5 e2 e3) => ((is_e_of_e e1) /\ (is_e_of_e e2) /\ (is_e_of_e e3))
end.

Fixpoint is_L_of_L (L_6:L) : Prop :=
  match L_6 with
  | L_Nil => (True)
  | (L_LMapping L5 e_v_list) => ((is_L_of_L L5) /\ is_L_of_e_e_list e_v_list)
  | (L_LRepl L5 e5 id5) => ((is_L_of_L L5) /\ (is_e_of_e e5))
end.

Lemma eq_r: forall (x y : r), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_r : ott_coq_equality.

Lemma eq_list_r: forall (x y : list_r), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith. 
Defined.
Hint Resolve eq_list_r : ott_coq_equality.

Lemma eq_rr: forall (x y : rr), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith. 
Defined.
Hint Resolve eq_rr : ott_coq_equality.

Lemma eq_l: forall (x y : l), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_l : ott_coq_equality.

Lemma eq_om: forall (x y : om), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_om : ott_coq_equality.

Lemma eq_list_om: forall (x y : list_om), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_om : ott_coq_equality.


Lemma eq_Omega: forall (x y : Omega), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Omega : ott_coq_equality.

Lemma eq_Ost: forall (x y : Ost), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Ost : ott_coq_equality.

Lemma eq_rs: forall (x y : rs), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_rs : ott_coq_equality.

Lemma eq_phi: forall (x y : phi), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_phi : ott_coq_equality.

Lemma eq_list_phi: forall (x y : list_phi), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_phi : ott_coq_equality.

Lemma eq_P: forall (x y : P), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_P : ott_coq_equality.

Lemma eq_Pst: forall (x y : Pst), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Pst : ott_coq_equality.

Lemma eq_q: forall (x y : q), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_q : ott_coq_equality.

Lemma eq_list_q: forall (x y : list_q), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_q : ott_coq_equality.

Lemma eq_Q: forall (x y : Q), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Q : ott_coq_equality.

Lemma eq_M: forall (x y : M), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_M : ott_coq_equality.


Lemma eq_K: forall (x y : K), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_K : ott_coq_equality.

Lemma eq_H: forall (x y : H), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_H : ott_coq_equality.


Lemma eq_bv: forall (x y : bv), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_bv : ott_coq_equality.

Lemma eq_iv: forall (x y : iv), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_iv : ott_coq_equality.

Lemma eq_fresh: forall (x y : fresh), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_fresh : ott_coq_equality.

Lemma eq_id: forall (x y : id), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_id : ott_coq_equality.

Lemma eq_list_r_r: forall (x y : list_r_r), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_r_r : ott_coq_equality.


Fixpoint eq_T (x y : T): {x = y} + {x <> y}
with eq_list_T (x y : list_T): {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_T : ott_coq_equality.
Hint Resolve eq_list_T : ott_coq_equality.



Lemma eq_privs: forall (x y : privs), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_privs : ott_coq_equality.

Lemma eq_rho: forall (x y : rho), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_rho : ott_coq_equality.

Lemma eq_list_rho: forall (x y : list_rho), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_rho : ott_coq_equality.

Fixpoint eq_e (x y : e): {x = y} + {x <> y} 
with eq_list_e (x y : list_e): {x = y} + {x <> y}
with eq_ee (x y : ee): {x = y} + {x <> y}
with eq_emem (x y : emem): {x = y} + {x <> y}.
Proof.

  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_e : ott_coq_equality.
Hint Resolve eq_list_e : ott_coq_equality.
Hint Resolve eq_ee : ott_coq_equality.
Hint Resolve eq_emem : ott_coq_equality.

Lemma eq_list_e_T: forall (x y : list_e_T), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_e_T : ott_coq_equality.

Lemma eq_G: forall (x y : G), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_G : ott_coq_equality.

Lemma eq_list_e_e: forall (x y : list_e_e), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_e_e : ott_coq_equality.

Lemma eq_L: forall (x y : L), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_L : ott_coq_equality.

Lemma eq_E: forall (x y : E), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_E : ott_coq_equality.

Lemma eq_list_E: forall (x y : list_E), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_E : ott_coq_equality.


Inductive list_id : Set := Nil_list_id | Cons_list_id (_:id) (tl_ : list_id).

Fixpoint map_list_id (A:Set) (f:id->A) (l0:list_id) : list A :=
  match l0 with
  | Nil_list_id => nil
  | Cons_list_id h tl_ => cons (f h) (map_list_id A f tl_)
  end.
Implicit Arguments map_list_id.

Fixpoint make_list_id (l0: list id): list_id :=
  match l0 with
  | nil  => Nil_list_id
  | cons h tl_ => Cons_list_id h (make_list_id tl_)
  end.

Fixpoint unmake_list_id (l0: list_id): list id :=
  match l0 with
  | Nil_list_id => nil
  | Cons_list_id h tl_ => cons h (unmake_list_id tl_)
  end.

Fixpoint nth_list_id (n:nat) (l0: list_id) {struct n} : option id :=
  match n,l0 with
  | O, Cons_list_id h tl_ => Some h
  | O, _ => None
  | S m, Nil_list_id => None
  | S m, Cons_list_id h tl_ => nth_list_id m tl_
  end.

Fixpoint app_list_id (l0 m: list_id): list_id :=
  match l0 with
  | Nil_list_id => m
  | Cons_list_id h tl_ => Cons_list_id h (app_list_id tl_ m)
  end.

(** definitions *)
(* FIXME: make this type correctly *)
Definition IntOp (_ _:e) := E_PlaceHolder.
Definition Comp (_ _:e) := E_PlaceHolder.

(* how to do the substitution? *)
Fixpoint apply_mem (S:list emem) (E : E) :=
match S, E with
| S', [] => S'
| S', (em_ReadE _ _ _ _)::E' => apply_mem S' E'
| S', (em_WriteE l _ v _)::E' => (apply_mem S' E')  (* [v/l] *)
| S', (em_ReduceIdE l _ v _)::E' => let S' := apply_mem S E' in
                                    S' (* S'[id(S'(l),v)/l]  *)
end.

Fixpoint coherent (S:list emem) (L1:list emem) (L2:list emem) (E: list emem) :=
  match S, L1, L2, E with
| S', L1', L2', [] => True
| S', L1', L2', eps :: E' =>
  match eps with
  | em_ReadE l c v t => 
    (* In l L2 -> *) coherent S' L1' L2' E'
  | em_WriteE l c v t =>
    ( (* In l L1 -> *) coherent (apply_mem S' [eps]) L1' (* (l:: *) (L2') E') \/
    coherent (apply_mem S' [eps]) L1' L2' E'
  | _ =>
    coherent (apply_mem S' [eps]) L1' L2' E'
  end
end.

(* think you need an accumulator here
one of the things you have to do is take an element off until you reach the end of it.


 *)

(* remainder list, implemented separately to shut up Coq's termination checker *)

Fixpoint rem_list m (acc: list (list emem)) (l: list (list emem)) :=
  match l with
  | [] => []
  | E :: l' =>
    match E with
    | [] => rem_list m (acc++[[]]) l'
    | a :: E' =>
      if eq_emem m a then
        acc ++ [E'] ++ l'
      else
        rem_list m (acc ++ [E]) l'
    end
  end.

Fixpoint any_interleave (E:list emem) (l:list (list emem)) :=
  match E with
  | [] =>
    if fold_right (fun a b => andb
                              (match a with
                               | [] => true
                               | _ => false
                               end)
                                 b) true l then
      True
    else
      False
  | a :: l' =>
    any_interleave l' (rem_list a [] l)
    (* need a list with a front and back
       so you need an accumulator.
     *)
  end.

Fixpoint member m l :=
  match l with
  | [] => false
  | m' :: l' =>
    if eq_emem m m' then
      true
    else
      member m l'
  end.

Fixpoint Lexcl E (C:list emem) :=
  filter (fun x => negb (member x C))
         (filter (fun a =>
            match a with
            | em_ReadE l priv_excl v t => true
            | em_WriteE l priv_excl  v t => true
            | em_ReduceIdE l priv_excl v t => true
            | _ => false 
            end) E).

Fixpoint Latomic E (C:list emem) :=
  filter (fun x => negb (member x (C++(Lexcl E C))))
         (filter (fun a =>
            match a with
            | em_ReadE l priv_atomic v t => true
            | em_WriteE l priv_atomic  v t => true
            | em_ReduceIdE l priv_atomic v t => true
            | _ => false 
            end) E).

Fixpoint seq_equiv S L1 L2 (E':E) (l: list E) :=
  coherent S L1 L2 (fold_right (fun a b => a ++ b) [] l) /\
  forall l, apply_mem S E'  = apply_mem S (fold_right (fun a b => a ++ b) [] l).

Fixpoint down_t (t:e) (E: list emem) :=
  match E with
  | [] => []
  | em_ReadE l c v t' :: E' =>
    if eq_e t t' then
      (em_ReadE l c v t') :: down_t t E'
    else
      E'
  | em_WriteE l c  v t' :: E' => 
    if eq_e t t' then
      (em_WriteE l c v t') :: down_t t E'
    else
      E'
  | em_ReduceIdE l c v t' :: E' =>
    if eq_e t t' then
      (em_ReduceIdE l c v t') :: down_t t E'
    else
      E'
  end.

Fixpoint valid_interleave S C (E':E) (l: list E) :=
  any_interleave ([E']++l) /\
  coherent S (Lprivs E' C) (Lprivs E' C) E' /\
  seq_equiv S (Lprivs  E' C) (Lprivs E' C) E' l /\ 
  forall t, seq_equiv S (Latomic E' C) nil (down_t t E') [(down_t t (fold_right (fun a b => a ++ b) [] l))].

(* fold append here *)

(* what is mark coherence doing here? *)

Fixpoint mark_coherence l (Q:Q) (taskid:nat):privs :=
match l,Q with
| [],Q' => priv_excl
| em_ReadE l c v t :: E', Q' => priv_atomic
| em_WriteE l c v t :: E', Q' => priv_atomic
| em_ReduceIdE l c v t :: E', Q'  => priv_atomic
end.


(* defns Jtype *)
Inductive typing : G -> P -> Omega -> e -> T -> Prop :=    (* defn typing *)
 | T_Read : forall p (r_list:list_r) (G5:G) (P5:P) (Omega5:Omega) (e1:e) (T5:T) (t101 t102:r)
     (type1checks: typing G5 P5 Omega5 e1 (T_Pointer T5 r_list)),
          nth_list_r (p - 1) r_list = Some t101 ->
     nth_list_r (p - 1) r_list = Some t102 ->
is_G_of_G G5 ->
     is_e_of_e e1 ->
     typing G5 P5 Omega5 (E_Read e1) T5
 | T_Write : forall (r_list:list_r) (G5:G) (P5:P) (Omega5:Omega) (e1 e2:e) (T5:T)
     (type1checks: typing G5 P5 Omega5 e1 (T_Pointer T5 r_list))
     (type2checks: typing G5 P5 Omega5 e2 T5),
     is_G_of_G G5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     typing G5 P5 Omega5 (E_Write e1 e2) (T_Pointer T5 r_list)
 | T_Reduce : forall (r_list:list_r) (G5:G) (P5:P) (Omega5:Omega) (id5:id) (e1 e2:e) (T1 T2:T)
     (type1checks: typing G5 P5 Omega5 e1 (T_Pointer T1 r_list))
     (type2checks: typing G5 P5 Omega5 e2 T2),
     is_G_of_G G5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     typing G5 P5 Omega5 (E_Reduce id5 e1 e2) (T_Pointer T1 r_list)
 | T_New : forall (G5:G) (P5:P) (Omega5:Omega) (T5:T) (r5:r),
     is_G_of_G G5 ->
     typing G5 P5 Omega5 (E_New T5 r5) (T_PointerOne T5 r5)
 | T_UpRgn : forall (r'_list r_list:list_r) (G5:G) (P5:P) (Omega5:Omega) (e1:e) (T5:T) (e_5:e)
     (renamedregion: typing G5 P5 Omega5 e_5 (T_Pointer T5 r'_list)),
     is_G_of_G G5 ->
     is_e_of_e e1 ->
     is_e_of_e e_5 ->
     typing G5 P5 Omega5 (E_UpRegion e1 r_list) (T_Pointer T5 r_list)
 | T_DnRgn : forall (r'_list r_list:list_r) (G5:G) (P5:P) (Omega5:Omega) (e5:e) (T5:T)
     (haverenamed: typing G5 P5 Omega5 e5 (T_Pointer T5 r'_list)),
     is_G_of_G G5 ->
     is_e_of_e e5 ->
     typing G5 P5 Omega5 (E_DownRegion e5 r_list) (T_Pointer T5 r_list)
 | T_NewColor : forall (G5:G) (P5:P) (Omega5:Omega) (r5:r),
     is_G_of_G G5 ->
     typing G5 P5 Omega5 (E_NewColor r5) (T_RegionColoring r5)
 | T_Color : forall (G5:G) (P5:P) (Omega5:Omega) (e1 e2 e3:e) (r5:r) (T5:T)
     (type1checks: typing G5 P5 Omega5 e1 (T_RegionColoring r5))
     (type2checks: typing G5 P5 Omega5 e2 (T_PointerOne T5 r5))
     (type3checks: typing G5 P5 Omega5 e3 T_Va),
     is_G_of_G G5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_e_of_e e3 ->
     typing G5 P5 Omega5 (E_Color e1 e2 e3) (T_RegionColoring r5)
 | T_Partition : forall (r_list:list_r) (p:index) (G5:G) (P5:P) (Omega5:Omega) (e1 e2:e) (T5:T) (Omega':Omega) (t103 t104:r)
     (firstargcoloring: typing G5 P5 Omega5 e1 (T_RegionColoring t103))
     (type2checks: typing G5 P5 Omega' e2 T5),
          nth_list_r (p - 1) r_list = Some t103 ->
     nth_list_r (p - 1) r_list = Some t104 ->
is_G_of_G G5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     typing G5 P5 Omega5 (E_Part t104 e1 r_list e2) T5
 | T_Pack : forall (r_r'_list:list_r_r) (G5:G) (P5:P) (Omega5:Omega) (e1:e) (T1 T2:T)
     (type1checks: typing G5 P5 Omega5 e1 (T_TypeRepl T2 r_r'_list)),
     is_G_of_G G5 ->
     is_e_of_e e1 ->
     typing G5 P5 Omega5 (E_Pack e1 T1) T1
 | T_UnPack : forall (G5:G) (P5:P) (Omega5:Omega) (e1:e) (id5:id) (T1:T) (e2:e) (T3:T) (G':G) (Omega':Omega)
     (type1checks: typing G5 P5 Omega5 e1 T1)
     (type2checks: typing G' P5 Omega' e2 T3),
     is_G_of_G G5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_G_of_G G' ->
     typing G5 P5 Omega5 (E_Unpack e1 id5 T1 e2) T3
 | T_Call : forall (e_list:list_e) (r_list:list_r) (G5:G) (P5:P) (Omega5:Omega) (id5:id) (T5:T), 
     is_G_of_G G5 ->
     (Forall (fun (e_:e) => is_e_of_e e_) (unmake_list_e e_list)) ->
     typing G5 P5 Omega5 (E_FuncCall id5 r_list e_list) T5
 | T_Program : forall (e_list:list_e) (r_list:list_r) (id_list:list_id) (G5:G) (P5:P) (Omega5:Omega) (T5:T),
     is_G_of_G G5 ->
     (Forall (fun (e_:e) => is_e_of_e e_) (unmake_list_e e_list)) ->
     typing G5 P5 Omega5 (E_FuncDefList (make_list_id_rr_ee (map_list_id (fun (id_:id) => (id_,(rr_Rlist r_list),(ee_Elist e_list))) id_list))) T5.
(** definitions *)

(* defns Jop *)
Inductive eval : M -> L -> H -> list emem -> list e -> e -> e -> E -> Prop :=    (* defn eval *)
 | EVa : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (x:termvar) (v5:e) (E5:E),
     is_L_of_L L5 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Va x) v5 E5
 | ERead1 : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e5:e) (E5:E) (l5:l) (privs5:privs) (v5:e) (Clobber':list emem)
     (prodvalue: eval M5 L5 H5 Clobber5 C5 e5 (E_MemoryLoc l5) E5)
     (apply:   Clobber'   =   (apply_mem Clobber5 E5)  )
     (memnotclobber:  (not (   In   (E_MemoryLoc l5)     C5    )) ),
     is_L_of_L L5 ->
     is_e_of_e e5 ->
     is_v_of_e v5 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Read e5) v5  ( E5  ++ [em_ReadE (E_MemoryLoc l5) privs5 v5 E_Zero] ) 
 | ERead2 : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e5:e) (l5:l) (E5:E) (privs5:privs) (v5:e) (Clobber':list emem)
     (prodvalue: eval M5 L5 H5 Clobber5 C5 e5 (E_MemoryLoc l5) E5)
     (apply:   Clobber'   =   (apply_mem Clobber5 E5)  )
     (memclobber:  In   (E_MemoryLoc l5)  C5  ),
     is_L_of_L L5 ->
     is_e_of_e e5 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Read e5) (E_HeapVal (H_Hl H5 l5))  ( E5 ++ [em_ReadE (E_MemoryLoc l5) privs5 v5 E_Zero] ) 
 | EWrite : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1 e2:e) (l5:l) (E_5 E1:E) (Clobber':list emem) (v5:e) (E2:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_MemoryLoc l5) E1)
     (prod2value: eval M5 L5 H5 Clobber' C5 e2 v5 E2)
     (validinterleave: valid_interleave Clobber5 Clobber' E_5 ([E1]++[E2])) 
     (apply:   Clobber'   =   (apply_mem Clobber5 E_5)  ) ,
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Write e1 e2) (E_MemoryLoc l5) E_5
 | EReduce : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (id5:id) (e1 e2:e) (l5:l) (E_5 E1:E) (Clobber':list emem) (v5:e) (E2:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_MemoryLoc l5) E1)
     (prod2value: eval M5 L5 H5 Clobber' C5 e2 v5 E2),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Reduce id5 e1 e2) (E_MemoryLoc l5) E_5
 | EReduceId : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (l5:l) (e1 e2 e3 v_5:e) (E_5:E) (v1:e) (E1:E) (Clobber':list emem) (v2:e) (E2:E) (v3:e) (E3:E) (v4:e)
     (prod1value: eval M5 L5 H5 Clobber5 C5 (E_MemoryLoc l5) v1 E1)
     (prod2value: eval M5 L5 H5 Clobber' C5 e1 v2 E2)
     (prod3value: eval M5 L5 H5 Clobber' C5 e2 v3 E3)
     (prod3value: eval M5 L5 H5 Clobber' C5 e3 v4 E3),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_e_of_e e3 ->
     is_v_of_e v_5 ->
     is_v_of_e v1 ->
     is_v_of_e v2 ->
     is_v_of_e v3 ->
     is_v_of_e v4 ->
     eval M5 L5 H5 Clobber5 C5 (E_Reduceid l5 e1 e2 e3) v_5 E_5
 | ENull : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 E_NullLoc E_NullLoc []
 | ENew : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (T5:T) (r5:r) (l5:l),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 (E_New T5 r5) (E_MemoryLoc l5) []
 | ENullTrue : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (T5:T),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 (E_NullFn T5 r_Null) (E_Base1 bv_True) []
 | ENullFalse : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (T5:T) (r5:r),
     is_L_of_L L5 ->
      (not (    (T_PointerOne T5 r5)   =   (T_PointerOne T5 r_Null)    ))  ->
     eval M5 L5 H5 Clobber5 C5 (E_NullFn T5 r5) (E_Base1 bv_False) []
 | EIsNullTrue : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (l5:l) (e1:e) (E1:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_MemoryLoc l5) E1),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
       (E_MemoryLoc l5)   =   E_NullLoc   ->
     eval M5 L5 H5 Clobber5 C5 (E_isNull (E_MemoryLoc l5)) (E_Base1 bv_True) []
 | EIsNullFalse : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (l5:l) (e1:e) (E1:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_MemoryLoc l5) E1),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
      (not (    (E_MemoryLoc l5)   =   E_NullLoc    ))  ->
     eval M5 L5 H5 Clobber5 C5 (E_isNull (E_MemoryLoc l5)) (E_Base1 bv_False) []
 | EUpRgn : forall (r_list:list_r) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e5 v5:e) (E5:E)
     (prodvalue: eval M5 L5 H5 Clobber5 C5 e5 v5 E5),
     is_L_of_L L5 ->
     is_e_of_e e5 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_UpRegion e5 r_list) v5 E5
 | EDnRgn1 : forall (r_list:list_r) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e5:e) (l5:l) (E5:E) (v5:e)
     (prodvalue: eval M5 L5 H5 Clobber5 C5 e5 v5 E5),
     is_L_of_L L5 ->
     is_e_of_e e5 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_DownRegion e5 r_list) (E_MemoryLoc l5) E5
 | EDnRgn2 : forall (r_list:list_r) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e5:e) (E5:E) (v5:e)
     (prodvalue: eval M5 L5 H5 Clobber5 C5 e5 v5 E5),
     is_L_of_L L5 ->
     is_e_of_e e5 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_DownRegion e5 r_list) E_NullLoc E5
 | EColor : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1 e2 e3:e) (K':K) (E':E) (l5:l) (E1:E) (Clobber':list emem) (v5:e) (E2:E) (Clobber'':list emem) (E3:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_MemoryLoc l5) E1)
     (prod2value: eval M5 L5 H5 Clobber' C5 e2 v5 E2)
     (prod3value: eval M5 L5 H5 Clobber'' C5 e3 v5 E3),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_e_of_e e3 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Color e1 e2 e3) (E_Kthing K') E'
 | ENewColor : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (r5:r) (K5:K),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 (E_NewColor r5) (E_Kthing K5) []
 | EPartition : forall (r_list:list_r) (p:index) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1 e2:e) (l5:l) (E':E) (K5:K) (E1:E) (Clobber':list emem) (v5:e) (E2:E) (t105:r)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_Kthing K5) E1)
     (prod2value: eval M5 L5 H5 Clobber' C5 e2 v5 E2),
          nth_list_r (p - 1) r_list = Some t105 ->
is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Part t105 e1 r_list e2) (E_MemoryLoc l5) E'
 | EPack : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1:e) (T1:T) (v':e) (E_5:E) (K5:K) (E1:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_Kthing K5) E1),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_v_of_e v' ->
     eval M5 L5 H5 Clobber5 C5 (E_Pack e1 T1) v' E_5
 | EUnpack : forall (rho_list:list_rho) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1:e) (id5:id) (T1:T) (e2 v2:e) (E':E) (v_5:e) (E1:E) (L':L) (v1:e) (M':M) (Clobber':list emem) (E2:E)
     (prod1memval: eval M5 L5 H5 Clobber5 C5 e1 (E_RegRelInst rho_list v_5) E1)
     (lreplace:   L'   =   (L_LRepl L5 v1 id5)  )
     (prod2value: eval M' L' H5 Clobber' C5 e2 v_5 E2),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_v_of_e v2 ->
     is_v_of_e v_5 ->
     is_L_of_L L' ->
     is_v_of_e v1 ->
     eval M5 L5 H5 Clobber5 C5 (E_Unpack e1 id5 T1 e2) v2 E'
 | ECall : forall (e_v_list:list_e_e) (r_list:list_r) (n:index) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (id5:id) (E'':E) (L':L) (t106:(e*e))
     (memreplace:   L'   =   (L_LMapping L5 e_v_list)  ),
          nth_list_e_e (n - 1) e_v_list = Some t106 ->
is_L_of_L L5 ->
     is_L_of_L L' ->
     (Forall (fun (tmp_:(e*e)) => match tmp_ with (e_,v_) => is_e_of_e e_ end) (unmake_list_e_e e_v_list)) ->
     (Forall (fun (tmp_:(e*e)) => match tmp_ with (e_,v_) => is_v_of_e v_ end) (unmake_list_e_e e_v_list)) ->
     eval M5 L5 H5 Clobber5 C5 (E_FuncCall id5 r_list (make_list_e (map_list_e_e (fun (e_:e) (v_:e) => e_) e_v_list))) (match t106 with (e_,v_) => v_ end) E''
 | EIntOp : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1 e2 v_5:e) (E_5:E) (v1:e) (E1:E) (v2:e) (E2:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 v1 E1)
     (prod2value: eval M5 L5 H5 Clobber5 C5 e2 v2 E2),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_v_of_e v_5 ->
     is_v_of_e v1 ->
     is_v_of_e v2 ->
     eval M5 L5 H5 Clobber5 C5 (E_IntOp e1 e2) v_5 E_5
 | EComp : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1 e2 v_5:e) (E_5:E) (v1:e) (E1:E) (v2:e) (E2:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 v1 E1)
     (prod2value: eval M5 L5 H5 Clobber5 C5 e2 v2 E2),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_v_of_e v_5 ->
     is_v_of_e v1 ->
     is_v_of_e v2 ->
     eval M5 L5 H5 Clobber5 C5 (E_Comp e1 e2) v_5 E_5
 | ELet : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (id5:id) (T5:T) (e1 e2 v_5:e) (E_5 E1:E) (v2:e) (E2:E) (L':L) (v1:e)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 v1 E1)
     (prod2value: eval M5 L5 H5 Clobber5 C5 e2 v2 E2),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_v_of_e v_5 ->
     is_v_of_e v1 ->
     is_v_of_e v2 ->
     is_L_of_L L' ->
     is_v_of_e v1 ->
       L'   =   (L_LRepl L5 v1 id5)   ->
     eval M5 L5 H5 Clobber5 C5 (E_Let id5 T5 e1 e2) v_5 E_5
 | EIfTrue : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1 e2 e3 v5:e) (E_5 E1:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_Base1 bv_True) E1)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e2 v5 E1),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_e_of_e e3 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_If e1 e2 e3) v5 E_5
 | EIfFalse : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e1 e2 e3 v5:e) (E_5 E1 E2:E)
     (prod1value: eval M5 L5 H5 Clobber5 C5 e1 (E_Base1 bv_False) E1)
     (prod2value: eval M5 L5 H5 Clobber5 C5 e3 v5 E2),
     is_L_of_L L5 ->
     is_e_of_e e1 ->
     is_e_of_e e2 ->
     is_e_of_e e3 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_If e1 e2 e3) v5 E_5
 | EFuncDef : forall (e_list:list_e) (r_list:list_r) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (id5:id) (v5:e) (E5:E) (L':L),
     is_L_of_L L5 ->
     is_v_of_e v5 ->
     is_L_of_L L' ->
     (Forall (fun (e_:e) => is_e_of_e e_) (unmake_list_e e_list)) ->
       L'   =   (L_LRepl L5 (E_FuncCall id5 r_list e_list) id5)   ->
     eval M5 L5 H5 Clobber5 C5 (E_FuncDef id5 r_list e_list) v5 E5
 | EFuncDefList : forall (id_rr_ee_list:list_id_rr_ee) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (v5:e) (E5:E),
     is_L_of_L L5 ->
     is_v_of_e v5 ->
     (Forall (fun (tmp_:(id*rr*ee)) => match tmp_ with (id_,rr_,ee_) => is_ee_of_ee ee_ end) (unmake_list_id_rr_ee id_rr_ee_list)) ->
     eval M5 L5 H5 Clobber5 C5 (E_FuncDefList id_rr_ee_list) v5 E5
 | ETypedExpr : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (e5:e) (T5:T) (v5:e) (E5:E),
     is_L_of_L L5 ->
     is_e_of_e e5 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 e5 v5 E5 ->
     eval M5 L5 H5 Clobber5 C5 (E_TypedExpr e5 T5) v5 E5
 | EPlace : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (E5:E),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 E_PlaceHolder E_PlaceHolder E5
 | Ebv : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (bv5:bv) (E5:E),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Base1 bv5) (E_Base1 bv5) E5
 | Eiv : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (iv5:iv) (E5:E),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Base2 iv5) (E_Base2 iv5) E5
 | ETuple : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (v1 v2:e) (E5:E),
     is_L_of_L L5 ->
     is_v_of_e v1 ->
     is_v_of_e v2 ->
     eval M5 L5 H5 Clobber5 C5 (E_Tuple v1 v2) (E_Tuple v1 v2) E5
 | ENullLoc : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (E5:E),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 E_NullLoc E_NullLoc E5
 | EMemoryLoc : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (l5:l) (E5:E),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 (E_MemoryLoc l5) (E_MemoryLoc l5) E5
 | ERegRelInst : forall (rho_list:list_rho) (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (v5:e) (E5:E),
     is_L_of_L L5 ->
     is_v_of_e v5 ->
     eval M5 L5 H5 Clobber5 C5 (E_RegRelInst rho_list v5) (E_RegRelInst rho_list v5) E5
 | EHeapVal : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (E5:E),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 (E_HeapVal H5) (E_HeapVal H5) E5
 | EKthing : forall (M5:M) (L5:L) (H5:H) (Clobber5:list emem) (C5:list e) (K5:K) (E5:E),
     is_L_of_L L5 ->
     eval M5 L5 H5 Clobber5 C5 (E_Kthing K5) (E_Kthing K5) E5.
Notation "G , P , O |- e : T ":= (typing G P O e T) (no associativity, at level 99). 
Notation "M , L , H , S , C |- e |-> v , E" := (eval M L H S C e v E) (no associativity, at level 99).

(* need theorem to prove that all top level e there is a typing rule *)

Theorem preservation : forall (e5:e) (t:T) (E:E) (M:M) (L:L) (H:H) (S:list emem) (C:list e) (T:T),
    exists v,
      eval M L H S C e5 v E ->
      typing G_EmptyContext P_EmptyPriv O_EmptyConstraint e5 T  ->
      exists G P Omega T, typing G P Omega v T.
Proof.
  intros.
  eexists.
  intros.
  exists G_EmptyContext.
  exists  P_EmptyPriv.
  exists O_EmptyConstraint.
  exists T0.
Admitted.


(*



Theorem paper1 :
 forall (e5:e) (t:T) (M:M) (H:H) (S:list emem) (C:C) (T1 T2:T)  G P O,
     typing G P O e5 T1 /\ eval M L H S C e5 v E /\ map_consist M O /\ local_val_consit L H /\ store_consist S H ->
     result_consist v H M T  /\ memory_trace_consist E H /\ trace_has_privs E P

Lemma E :M P  <-> forall O,
      O = read l c v t -> exists r l, In l (M r) /\ In (reads r) Phi
      /\
      O = write l c v t -> exists r l, In l (M r) /\ In (writes r) Phi
      /\
      O = reduceid l c v t -> exists r l, In l (M r) /\ In (reducesid r) Phi


phi_A (op1 l1 c1 v1 t1) (op2 l2 c2 v2 t2) <->
      phi_A (op1 l1 c1 v1 t1) (op2 l2 c2 v2 t2) \/
      c1 = atomic /\ c2 = atomic /\ t1 <> t2

Theorem paper4: 
forall (l: list (e * P)) M L H S,
     M ~ O /\ L ~H M(PARSE_ERROR "file legion.ott  line 1101 char 20 - 29" "multiple parses") /\ S ~ H ->
       valid_interleaving

Theorem paper5 :
 forall (e5:e) (t:T) (M:M) (H:H) (S:list emem) (C:C) (T1 T2:T)  G P O,
     (types1: typing G P O e1 T1)
     (types2: typing G P O e2 T1)
     (privsmatch: pound_M P1  P2)
     e1', e2' is a subexpression (represented by subtrees?)
     from E1' e1'
     from E2' e2'
     non interfering.


E :M     E.
( = read(l, c, v, t)  r, l  M(r)  reads(r)  ) 
( = write(l, c, v, t)  r, l  M(r)  writes(r)  ) 
( = reduceid(l, c, v, t)  r, l  M(r)  reducesid(r)  )
*)

Theorem progress : forall (e5:e) (t:T) (M:M) (H:H) (S:list emem) (C:list e) (T1 T2:T),
     exists E L v,
     typing G_EmptyContext P_EmptyPriv O_EmptyConstraint e5 T1  ->
       typing G_EmptyContext P_EmptyPriv O_EmptyConstraint v T2  ->
       eval M L H S C e5 v E.
Proof.
  intros.
  induction e5.
  - (* Va *)
  (*  eexists. *)
  exists [].
  exists L_Nil.
  exists E_PlaceHolder.
  intros.
  apply EVa.
  reflexivity.
  reflexivity.
  (* are memory locations some or none? *)
  - (* New *)
   (* eexists. *)
  exists ([]).
  exists L_Nil.
  exists (E_MemoryLoc ML_NilLoc).
  intros.
  apply ENew.
  reflexivity.
  - (* NullFn *)
    destruct r5.
    * (* NullFn True *)
      (* eexists. *)

      exists ([]).
      exists L_Nil.
      exists (E_Base1 bv_True).
      intros.
      apply ENullTrue.
      reflexivity.

    *   (* NullFn False *)
      (* eexists. *)
      exists ([]).
      exists L_Nil.
      exists (E_Base1 bv_False).
      intros.
      apply ENullFalse.
      reflexivity.
      unfold not.
      intros.
      destruct (eq_T (T_PointerOne T5 r_NotNull) (T_PointerOne T5 r_Null)).
      inversion H3.
      destruct n.
      assumption.
  - (* IsNull *)
    repeat eexists.
    intros.
    inversion H1.
  - (* UpRgn *)
    exists ([]).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    apply EUpRgn.
    inversion H2.
    reflexivity.
    inversion H2.
    reflexivity.
  - (* DnRgn *)
    exists ([]).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    inversion H2.
  - (* Read *)
    exists ([] ++ [em_ReadE (E_MemoryLoc ML_NilLoc) priv_excl (E_HeapVal (H_Hl H0 ML_NilLoc))  E_Zero]). 

    exists L_Nil. 
    repeat eexists.
    intros.
    destruct (In_dec eq_e (E_MemoryLoc ML_NilLoc) C0).
    (* how would I prove this in real life? should just work with rule2. *)
    (* the problem is that the inductive hypothesis is messed up *)
    apply ERead2 with (Clobber':=S).
    (* so we are proving that it always returns a memory location *)
    (* the inductive hypothesis should be that anything that typechecks for read
       so anything that any expression that can evaluate.
       Anything that doesn't type will contradict (If I do this right)
     *)
    
    inversion H2.
    intros.
    simpl.
    reflexivity.
    apply i.
    reflexivity.
    inversion H2.
    reflexivity.
    apply ERead1  with (Clobber':=S).
    inversion H2.
    reflexivity.
    apply n.
    reflexivity.
    inversion H2.
    reflexivity.
    reflexivity.
  - (* Write *) 
    exists ([]).
    exists L_Nil.
    repeat eexists.
    intros.
    apply EWrite with (E1:=[]) (Clobber':=[]) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=[]).
    inversion H2.
    inversion H2.
    simpl.
    intros.
    induction S.
    simpl.
    repeat (split; auto).
    intros.
    induction (fold_right (fun a b : list emem => a ++ b) [] l0).
    reflexivity.
    simpl.
    destruct a;inversion IHl1; reflexivity.
    simpl.
    repeat (split; auto).
    intros.
    induction (fold_right (fun a0 b : list emem => a0 ++ b) [] l0).
    reflexivity.

    destruct a0; simpl; assumption.
    ;inversion IHl1; reflexivity.

    reflexivity.
    reflexivity.
    reflexivity.
    ; reflexivity.
    rewrite <- IHl1.
    j
    apply IHl0.
    reflexivity.
    inversion H2.
    inversion H2.
    inversion H2.
    reflexivity.
  - (* Reduce *)
    exists ([]).
    exists L_Nil.
    repeat eexists.
    intros.
    apply EReduce with (E1:=[]) (Clobber':=S_Null) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=[]).
    inversion H2.
    inversion H2.
    reflexivity.
    inversion H2.
    inversion H2.
    reflexivity.
  - (* Reduceid *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    repeat eexists.
    intros.
    apply EReduceId with (E1:=[]) (Clobber':=S_Null) (v1:=(E_MemoryLoc ML_NilLoc)) (v2:=(E_MemoryLoc ML_NilLoc)) (v3:=(E_MemoryLoc ML_NilLoc)) (v4:=(E_MemoryLoc ML_NilLoc)) (E2:=[]) (E3:=[]).
    inversion H1.
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* NewColor *)
    exists ([]).
    exists L_Nil.
    Variable x0:K.
    exists (E_Kthing x0).
    intros.
    apply ENewColor.
    reflexivity.
  - (* Color *) 
    exists ([]).
    exists L_Nil.
    exists (E_Kthing x0).
    intros.
    apply EColor with (E1:=[]) (Clobber':=S_Null)  (Clobber'':=S_Null) (l5:=ML_NilLoc) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=[]) (E3:=[]).
    inversion H2.
    inversion H2.
    inversion H2.
    reflexivity.
    inversion H2.
    inversion H2.
    inversion H2.
    reflexivity.
  - (* IntOp *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EIntOp with  (E1:=[]) (E2:=[]) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    inversion H1.
    inversion H1.
    (* TODO: fill out IntOp *)
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Comp *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EComp with  (E1:=[]) (E2:=[]) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    inversion H1.
    inversion H1.
    (* TODO: fill out Comp *)
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Let *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply ELet with  (E1:=[]) (E2:=[]) (L':=L_Nil) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    inversion H1.
    inversion H2.
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  (* TODO: fill out substition *)
    inversion H1.
  - (* If *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H1.
  - (* Call *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H2.
  - (* Partition *)
     exists ([]).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    (* TODO: Get this unifying *)
    apply EPartition with (E1:=[]) (Clobber':=S_Null) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=[]) (K5:=K_Null) (p:=0).
    inversion H1.
    inversion H2.
    inversion H2.
    induction l0.
    simpl.
    inversion H2.
    simpl.
    inversion H2.
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* Pack *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EPack with (E1:=[]) (K5:=K_Null).
    inversion H2.
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* Unpack *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    introsa.
    apply EUnpack with (rho_list:=Nil_list_rho) (v_5:=E_PlaceHolder) (E1:=[]) (E2:=[])  (Clobber':=S_Null) (L':=L_Nil) (v1:=E_PlaceHolder) (M':=M_Null).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* FuncDef *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EFuncDef with (L':=L_Nil).
    reflexivity.
    reflexivity.
    reflexivity.
    (* TODO: list assumption needs cleanup *)
    induction l1.
    simpl.
    apply Forall_nil.
    apply Forall_cons.
    inversion H2.
    apply IHl1.
    inversion H1.
    (* TODO: really do the environment *)
    inversion H1.
  - (* FundDefList *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EFuncDefList.
    reflexivity.
    reflexivity.
    induction l0.
    simpl.
    apply Forall_nil.
    apply Forall_cons.
    inversion H2.
    apply IHl0.
    inversion H2.
  - (* TypedExpr *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply ETypedExpr.
    reflexivity.
    inversion H1.
    reflexivity.
    inversion H2.
  - (* PlaceHolder *)
    (* TODO: remove when no longer necessary *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H1.
  - (* BoolVal *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H1.
  - (* IntVal *)
    exists ([]).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H1.
  -  (* Tuple *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    apply ETuple.
    reflexivity.
    inversion H1.
    inversion H1.
  - (* NullLoc *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* MemoryLoc *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* RegRelInst *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* HeapVal *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
    (* TODO: Understand this and name it correctly *)
  - (* Kthing *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* True *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* False *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* Zero *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* Succ *)
    exists ([]).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
    Variable x1:E.
    Variable x2:L.
    Variable x3:e.
    Variable x4:l.
    Unshelve.
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
Qed.




