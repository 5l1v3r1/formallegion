metavar termvar, x ::= {{ com term variable }}
{{ isa string}} {{ coq nat}} {{ hol string}} {{ coq-equality }}
{{ ocaml int}} {{ lex alphanum}} {{ tex \mathit{[[termvar]]} }}

indexvar index, i, j, k, n, m, p  ::= {{ isa num }} {{ coq nat }} {{ hol num }}
grammar

T :: T_ ::=
  | bool :: :: Num
  | int :: :: Va
  | < T1 , .. , Tn > :: :: Tuple
  | T @ r :: :: PointerOne
  | T @ ( r1 , .. , rn ) :: :: Pointer
  | T [ r1 / r1' , .. , rn / rn' ] :: :: TypeRepl
  | coloring ( r ) :: :: RegionColoring
  | exists r1 , .. , rn . ( T1 , .. , Tm ) , P , Q -> Tr ::  :: Functions

flist :: fl_ ::=
| { fdef1 , .. , fdefn  } :: :: FuncList

fdef :: F_ ::=
| function :: :: FuncTok

r :: r_ ::=

rr :: rr_ ::=
| [ r1 , .. , rn ] :: :: Rlist

G {{ tex \Gamma }} :: G_ ::=
| { ( e1 : T1 ) , .. , ( en : Tn ) } :: :: Context
| emptyC :: :: EmptyContext

O {{ tex \Omega }} :: O_ ::=
| { om1 , .. , omn } :: :: RegionConstraint
| emptyO :: :: EmptyConstraint

Ost {{ tex \Omega^* }} :: Ost_ ::=
| { om1 , .. , omn } :: :: RegionConstraintSt
| emptyOst :: :: EmptyConstraintSt

rs :: O_ ::=
| { r1 , .. , rn } :: :: Regions
| emptyR :: :: EmptyRegion


om {{ tex \omega }} :: o_ ::=
| r1 <= r2 :: :: Subregion
| r1 * r2 :: :: Disjointness

P {{ tex \Phi }} :: P_ ::=
| { phi1 , .. , phin } :: :: Priv
| emptyP :: :: EmptyPriv

Pst {{ tex \Phi^* }} :: Pst_ ::=
| { phi1 , .. , phin } :: :: PrivSt
| emptyPst :: :: EmptyPrivSt


phi {{ tex \phi }} :: p_ ::=
| reads ( r )  :: :: Reads
| writes ( r ) :: :: Writes
| reducesid ( r ) :: :: Reduces

Q :: Q_ ::=
| { q1 , .. , qn } :: :: CoherenceModes

q :: q_ ::=
| atomic ( r ) :: :: Atomic
| simult ( r ) :: :: Simultaneous

rho {{ tex \rho }} :: rho_ ::=

v :: v_ ::=
| bv :: :: Base1
| iv :: :: Base2
| < v1 , v2 > :: :: Tuple
| null :: :: NullLoc
| l :: :: MemroyLoc
%| { ( l1 , iv ) , .. , ( ln , iv ) } :: :: Coloring
| < < rho1 , .. , rhon , v  > > :: :: RegRelInst

bv :: bv_ ::=
  | true                         ::   :: True       {{ com constant true }}
  | false                         ::   :: False      {{ com constant false }}

iv :: iv_ ::=
| 0 :: :: Zero
| S iv :: ::  Succ

ee :: ee_ ::=
| ( e1 , .. , en ) :: :: Elist

id :: id_ ::=

e :: E_ ::=
  | x :: :: Va
  | iv :: :: Aexp
  | bv :: :: Bexp
  | < e1,..,en > :: :: Tuple
  | e iv :: :: Proj
  | id :: :: Id
  | new T @ r :: :: New
  | null T @ r :: :: Null
  | isnull (  e ) :: :: isNull
  | upregion ( e , r1,..,rn ) :: :: UpRegion
  | downregion ( e , r1,..,rn ) :: :: DownRegion
  | read ( e ) :: :: Read
  | write ( e1 , e2 ) :: :: Write
  | reduce ( id , e1 , e2 ) :: :: Reduce
  | newcolor r :: :: NewColor
  | color ( e1 , e2 , e3 ) :: :: Color
  | e1 + e2 :: :: IntOp
  | e1 lt e2 :: :: Comp
  | let id : T =  e1 in e2 :: :: Let
  | if b then c0 else c1         ::  :: If         {{ com conditional }}
  | id [ r1 , .. , rn ] ( e1 , .. , em ) :: :: FuncCall
  | partition rp using e1 as r1 , .. , rn in e2 :: :: Part
  | pack e1 as T [ r1 , .. , rn ] :: :: Pack
  | unpack e1 as id :  T [ r1 , .. , rn ] in e2 :: :: Unpack
  | function id [ r1 , .. , rn ] ( e1 , .. , em ) :: :: FuncDef
  | { function id1 rr1 ee1 , .. , function idn rrn een }  :: :: FuncDefList
  %| {function id1 [ r1 , .. , rn ]1 ( e1 , .. , em )1 , .. , function idn [ r1 , .. , rn ]n ( e1 , .. , em )n }  :: :: FuncDefList

formula :: formula_ ::=  {{ com formulas }}
   |  judgement                       ::   :: judgement
          {{ com judgement }}
   |  not formula                     :: M :: not
          {{ com negated formula }}
          {{ tex \neg [[formula]] }}
          {{ coq ~[[formula]] }}
   |  ( formula )                     :: M :: brackets
          {{ com bracketed }}
          {{ tex \left([[formula]]\right) }} {{ isa ([[formula]]) }}
          {{ coq [[formula]] }}
   |  ALL i . phi in P :: M :: AllP
          {{ com for all variables in domain of $[[P]]$ }}
           {{ tex \forall_[[i]]. [[phi]] \in [[P]] }}
           {{ coq               forall [[i]]:[[P]], [[phi]] }}
   |  ALL i . phi in Pst :: M :: AllPst
           {{ com for all variables in domain of $[[Pst]]$ }}
           {{ tex \forall_[[i]]. [[phi]] \in [[Pst]] }}
           {{ coq               forall [[i]]:[[Pst]], [[phi]] }}
   |  EX i . phi in P :: M :: Exists
           {{ com for all variables in domain of $[[P]]$ }}
           {{ tex \exists_[[i]]. [[phi]] \in [[P]] }}
           {{ coq               exists [[i]]:[[P]], [[phi]] }}
   |  ALL i . om in O :: M :: AllO
           {{ com for all variables in domain of $[[O]]$ }}
           {{ tex \forall_[[i]]. [[om]] \in [[O]] }}
           {{ coq               forall [[i]]:[[O]], [[om]] }}
   |  ALL i . om in Ost :: M :: AllOst
           {{ com for all variables in domain of $[[Ost]]$ }}
           {{ tex \forall_[[i]]. [[om]] \in [[Ost]] }}
           {{ coq               forall [[i]]:[[Ost]], [[om]] }}
   |  EX i . om in O :: M :: ExistsO
           {{ com for all variables in domain of $[[O]]$ }}
           {{ tex \exists_[[i]]. [[om]] \in [[O]] }}
           {{ coq               exists [[i]]:[[O]], [[om]] }}
   |  EX i . om in Ost :: M :: ExistsOst
           {{ com for all variables in domain of $[[Ost]]$ }}
           {{ tex \exists_[[i]]. [[om]] \in [[Ost]] }}
           {{ coq               exists [[i]]:[[Ost]], [[om]] }}
   |  ALL i . formula :: M :: AllF
           {{ com for all variables in $[[i]]$ and $[[formula]]$ }}
           {{ tex \forall_[[i]]. [[formula]] }}
           {{ coq               forall [[i]], [[formula]] }}
   |  EX formula1 . formula2 :: M :: ExistsF
           {{ com for all variables in $[[formula1]]$ and $[[formula2]]$ }}
           {{ tex \exists_[[formula1]]. [[formula2]] }}
           {{ coq               exists [[formula1]], [[formula2]] }}
   |  EX formula1 . formula2 WHERE formula3 :: M :: ExistsFW
           {{ com exists $[[formula1]]$ and $[[formula2]]$ where $[[formula3]]$ }}
           {{ tex \exists_[[formula1]]. [[formula2]] \text{ where } [[formula3]] }}
           {{ coq               exists [[formula1]], [[formula2]] }}

   | G ( id ) :: :: Lookup
           {{ com lookup }}
           {{ tex \[[G]]([[id]]) }}
           {{ coq               In [[id]] [[G]] }}
   | formula1 = formula2 :: :: Equality
           {{ com equality }}
           {{ tex [[formula1]] = [[formula2]] }}
           {{ coq [[formula1]] = [[formula2]] }}
   | formula1 /\ formula2 :: :: And
           {{ com equality }}
           {{ tex [[formula1]] \land [[formula2]] }}
           {{ coq [[formula1]] /\ [[formula2]] }}
   | BAND  i . formula :: M :: BigAnd
           {{ com and fold on $[[i]]$ and $[[formula]]$ }}
           {{ tex \bigwedge_[[i]]. [[formula]] }}
           {{ coq Band [[i]] [[formula]] }}
   | formula1 INTR formula2 :: M :: Intersect
          % {{ com intersection of [[formula1]] [[formula2]] }}
           {{ tex [[formula1]] \cap [[formula2]] }}
           {{ coq Intersection ([[formula1]]) ([[formula2]]) }}
   | formula1 UNION formula2 :: M :: Union
          % {{ com union of [[formula1]] [[formula2]] }}
           {{ tex [[formula1]] \cup [[formula2]] }}
           {{ coq Intersection [[formula1]] [[formula2]] }}
   | formula1 SUB formula2 :: M :: Subset
          % {{ com [[formula1]] is subset of [[formula2]] }}
           {{ tex [[formula1]] \subseteq [[formula2]] }}
           {{ coq Subset [[formula1]] [[formula2]] }}
   | G , P , O -> T :: :: TypeImpl
           {{ com impl }}
           {{ tex [[G]],[[P]],[[O]] \rightarrow [[T]] }}
           {{ coq [[G]],[[P]],[[O]] -> [[T]] }}
   | G , P , Q -> T :: :: QthingImpl
           {{ com impl }}
           {{ tex [[G]],[[P]],[[Q]] \rightarrow [[T]] }}
           {{ coq [[G]],[[P]],[[Q]] -> [[T]] }}
  | r1 , .. , rn :: :: RegL
  {{ com region list }}
  | phi :: :: Perm
  {{ com phi }}
  {{ tex [[phi]] }}
  {{ coq [[phi]] }}
  | om :: :: omegas
  {{ com om }}
  {{ tex [[om]] }}
  {{ coq [[om]] }}
  | O :: :: Perms
  | P :: :: Phi
  | Pst :: :: PhiStar
  | P [ r1 / r1' , .. , rn / rn' ] :: :: PhiRepl
  | T [ r1 / r1' , .. , rn / rn' ] :: :: TypeRepl
  | G [ r1 / r1' , .. , rn / rn' ] :: :: TypeContextRepl
  | G [ e1 / T1 , .. , en / Tn ] :: :: TypeReplRepl
  | G :: :: TypeContF
  | G [ T [ r1 / r1' , .. , rn / rn' ] / id ] :: :: TypeContextElement
  | O [ r1 / r1' , .. , rn / rn' ] :: :: CompRepl
  | regions_of ( G , T ) :: :: RegionsOf2
  | regions_of ( G , T1, T2 ) :: :: RegionsOf3
  | rs :: :: RegionsForm
  | T :: :: TypeForm

terminals :: terminals_ ::=
  | EX  ::   :: exists          {{ tex \exists }}
  | ALL ::   :: forall          {{ tex \forall }}
  | in                         ::   :: in              {{ tex \in }}
  | om                      ::   :: omega           {{ tex \omega }}
  | phi                        ::   :: phi             {{ tex \phi }}
  | rho                        ::   :: rho             {{ tex \rho }}
  | \/                         ::   :: lor             {{ tex \lor }}
  | /\                         ::   :: land            {{ tex \land }}
  | ~                          ::   :: neg             {{ tex \neg }}
  %| <                         ::   :: lt            {{ tex < }}
  | *                         ::   :: sep {{ tex * }}
  | <=                         ::   :: leq            {{ tex \leq }}
  | -->                        ::   :: longrightarrow {{ tex \longrightarrow }}
  | ->                         ::   :: rightarrow     {{ tex \rightarrow }}
  | =>                         ::   :: Rightarrow     {{ tex \Rightarrow }}
  | \                          ::   :: lambda         {{ tex \lambda }}
  | |->                        ::   :: mapsto         {{ tex \mapsto }}
  | |-                         ::   :: vdash          {{ tex \vdash }}
  | emptyC                      ::   :: varnothingC     {{ tex \varnothing }}
  | emptyO                      ::   :: varnothingO     {{ tex \varnothing }}
  | emptyR                      ::   :: varnothingR     {{ tex \varnothing }}
  | emptyP                      ::   :: varnothingP     {{ tex \varnothing }}
  | *                          ::   :: times          {{ tex \times }}
  | <:                         ::   :: subtype        {{ tex <: }}
  | <                          ::   :: langle         {{ tex \langle }}
  | >                          ::   :: rangle         {{ tex \rangle }}
  | lt                         ::   :: lt             {{ tex < }}
  | \\                         ::   :: Downarrow      {{ tex \Downarrow }}
  | state                      ::   :: sigma          {{ tex \sigma }}
  | G                          ::   :: Gamma          {{ tex \Gamma }}
  | E                          ::   :: varepsilon        {{ tex \varepsilon }}

defns
Jtype :: '' ::= 

defn
G , P , O |- e : T :: :: typing :: T_ {{ com Typing }} by

G,P,O |- e1 : T@(r1,..,rn) [[:type1checks]]
ALL i . reads(ri) in Pst [[:readperm]]
----------------- :: Read
G,P,O |- read(e1) : T

G,P,O |- e1 : T@(r1,..,rn) [[:type1checks]]
G,P,O |- e2 : T [[:type2checks]]
ALL i . writes(ri) in Pst [[:writeperm]]
----------------- :: Write
G,P,O |- write(e1,e2) : T@(r1,..,rn)

% potentially need to do a fix here
{(e1:T1),(e2:T2)},emptyP,emptyO -> T1 [[:impl]]
G,P,O |- e1 : T1@(r1,..,rn) [[:type1checks]]
G,P,O |- e2 : T2 [[:type2checks]]
ALL i . reducesid(ri) in Pst [[:regionscanreduce]]
----------------- :: Reduce
G,P,O |- reduce(id,e1,e2) : T1@(r1,..,rn)


----------------- :: New
G,P,O |- new T@r : T@r

G,P,O |- e : T@(r1',..,rk') [[:renamedregion]]
ALL i . EX j . ri' <= rj in Ost [[:alwaysaless]]
----------------- :: UpRgn 
G,P,O |- upregion(e1,r1,..,rn) : T@(r1,..,rn)

G,P,O |- e : T@(r1',..,rk') [[:haverenamed]]
----------------- :: DnRgn 
G,P,O |- downregion(e, r1,..,rn) : T@(r1,..,rn)

----------------- :: NewColor
G,P,O |- newcolor r : coloring(r)

G,P,O |- e1 : coloring(r) [[:type1checks]]
G,P,O |- e2 : T@r [[:type2checks]]
G,P,O |- e3 : int [[:type3checks]]
----------------- :: Color
G,P,O |- color(e1,e2,e3) : coloring(r)

G,P,O |- e1 : coloring(rp) [[:firstargcoloring]]
(O' = O) /\ ((BAND i . ri <= rp) /\ (BAND j. ri * rj)) [[:everythingless]]
G,P,O' |- e2 : T [[:type2checks]]
(({r1,..,rk}) INTR regions_of(G,T)) = emptyR [[:allregionsempty]]
----------------- :: Partition
G,P,O |- partition rp using e1 as r1,..,rk in e2: T

T1 = EX r1',..,rk'.T2 WHERE O1 [[:existstype]]
O1[r1/r1',..,rk/rk'] SUB O' [[:renamedsub]]
G,P,O |- e1 : T2[r1/r1',..,rk/rk'] [[:type1checks]]
----------------- :: Pack
G,P,O |- pack e1 as T1[r1,..,rk]:T1

% T1 = exists r1',..,rk'.T2 where O 
T1 = EX r1',..,rk'.T2 WHERE O1 [[:typeexists]]
G,P,O |- e1 : T1 [[:type1checks]]
G' = G[T2[r1/r1',..,rk/rk']/id] [[:renamedtypecontext]]
O' = (O UNION O1[r1/r1',..,rk/rk']) [[:renamedpermissions]]
G',P,O' |- e2 : T3 [[:type2checks]]
({r1,..,rk} INTR regions_of(G,T1,T3)) = emptyR [[:allregionsempty]]
----------------- :: UnPack
G,P,O |- unpack e1 as id: T1[r1,..,rk] in e2:T3

%{(e1:T1),..,(en:Tn)}
G,P',Q' -> T [[:impl]]
G,P,O |- e1 : T[r1/r1',..,rk/rk'] [[:typerename1check]]
P'[r1/r1',..,rk/rk'] SUB Pst  [[:renamedsub]]
----------------- :: Call
 G,P,O |- id[r1,..,rk](e1,..,em) : T

%Tr[r1/r1',..,rk/rk'] }}
% really there isn't much going on here.
% it's just a list of functions.
% and you are saying that. for each context the memory regions typecheck
%{{ for 1 <= i <= p,

% so this is actually a list of all these things.
% which means that I need to define a subset

%{(e1:T1),..,(en:Tn)}
trip1,..,tripp
G,P',Q' -> T [[:impl]]
O1[r1/r1',..,rk/rk'] SUB O' [[:replsubset]]
G = G[e1/T1,..,em/Tm]
----------------- :: Program
G,P,O |- {function id1 [r1,..,rk] (e1,..,em),..,function idn [r1,..,rk] (e1,..,em)} : T

