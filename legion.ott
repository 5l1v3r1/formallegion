embed {{ coq
Require Import Nat.
}}

metavar termvar, x ::= {{ com term variable }}
{{ isa string}} {{ coq nat}} {{ hol string}} {{ coq-equality }}
{{ ocaml int}} {{ lex alphanum}} {{ tex \mathit{[[termvar]]} }}

indexvar index, i, j, k, n, m, p  ::= {{ isa num }} {{ coq nat }} {{ hol num }}
grammar

T :: T_ ::= {{ coq-equality decide equality. apply eq_value_name. }}
  | bool :: :: Num
  | int :: :: Va
  | < T1 , .. , Tn > :: :: Tuple
  | T @ r :: :: PointerOne
  | T @ ( r1 , .. , rn ) :: :: Pointer
  | T [ r1 , .. , rn ] :: :: TypeList
  | T [ r1 / r1' , .. , rn / rn' ] :: :: TypeRepl
  | coloring ( r ) :: :: RegionColoring
  | exists r1 , .. , rn . ( T1 , .. , Tm ) , P , Q -> Tr ::  :: Functions

fresh :: ti_ ::=
| iv :: :: TaskNum {{ coq [[iv]] }}

fns :: '' ::=
|    apply ( S , E ) :: :: apply
|    valid_interleave ( S , C , E1 , .. , En ) :: :: valid_interleave
|    taskid fresh :: :: taskid
|    mark_coherence ( E , M , taskid ) :: :: MarkCoherence {{coq (mark_coherence ([[E]]) ([[M]]) taskid) }}

r :: r_ ::=
| nullr :: :: Null
| notnullr :: :: NotNull

rr :: rr_ ::=
| [ r1 , .. , rn ] :: :: Rlist

l :: ML_ ::=
| nil :: :: NilLoc

G {{ tex \Gamma }} :: G_ ::=
| { ( e1 : T1 ) , .. , ( en : Tn ) } :: :: Context
| emptyC :: :: EmptyContext

O {{ tex \Omega }} {{ coq Omega }} :: O_ ::=
| { om1 , .. , omn } :: :: RegionConstraint
| emptyO :: :: EmptyConstraint

Ost {{ tex \Omega^* }} :: Ost_ ::=
| { om1 , .. , omn } :: :: RegionConstraintSt
| emptyOst :: :: EmptyConstraintSt

rs :: O_ ::=
| { r1 , .. , rn } :: :: Regions
| emptyR :: :: EmptyRegion


om {{ tex \omega }} :: o_ ::=
| r1 <= r2 :: :: Subregion
| r1 * r2 :: :: Disjointness

P {{ tex \Phi }} :: P_ ::=
| { phi1 , .. , phin } :: :: Priv
| emptyP :: :: EmptyPriv

Pst {{ tex \Phi^* }} :: Pst_ ::=
| { phi1 , .. , phin } :: :: PrivSt
| emptyPst :: :: EmptyPrivSt


phi {{ tex \phi }} :: p_ ::=
| reads ( r )  :: :: Reads {{coq (reads [[r]])}}
| writes ( r ) :: :: Writes {{coq (writes [[r]])}}
| reducesid ( r ) :: :: Reduces {{coq (reduces [[r]])}}

Q :: Q_ ::=
| { q1 , .. , qn } :: :: CoherenceModes

q :: q_ ::=
| atomic ( r ) :: :: Atomic
| simult ( r ) :: :: Simultaneous

M :: M_ ::=
| nullm :: :: Null
| M [[ Q ]] :: :: Qexpr

L :: L_ ::=
| nil :: :: Nil
| L [ ( e1 , v1 ) , .. , ( en , vn ) ]  :: :: LMapping
| L [ e / id ] :: :: LRepl

K :: K_ ::=
| nullk :: :: Null

H :: H_ ::=
| H ( l ) :: :: Hl

S {{ coq Clobber }} :: S_ ::=
| nullc :: :: Null 

C :: C_ ::=

E :: E_ ::=
| [ ] :: :: NullE
| [ e ] :: :: exp
| E ++ [ e ] :: :: Append {{ coq (E_Append [[E]] [[e]]) }}

rho {{ tex \rho }} :: rho_ ::=


v :: v_ ::=
| bv :: :: Base1 {{ coq [[bv]] }}
| iv :: :: Base2 {{ coq [[iv]] }}
| < v1 , v2 > :: :: Tuple
| null :: :: NullLoc
%{{ coq [] }}
| l :: :: MemoryLoc
% {{ coq [[l]]}}
%| { ( l1 , iv ) , .. , ( ln , iv ) } :: :: Coloring
| < < rho1 , .. , rhon , v  > > :: :: RegRelInst
%| S  :: :: Sthing
| H :: :: HeapVal
%{{ coq [[H]]}}
| K :: :: Kthing
%{{ coq [[K]]}}
  | place :: :: PlaceHolder


bv :: bv_ ::=
  | true                         ::   :: True       {{ com constant true }}
  | false                         ::   :: False      {{ com constant false }}

iv :: iv_ ::=
| 0 :: :: Zero
%{{ coq O}}
| S iv :: ::  Succ
%{{ coq Datatypes.S [[iv]]}}

ee :: ee_ ::=
| ( e1 , .. , en ) :: :: Elist

id :: id_ ::=

excl :: excl_ ::=

e :: E_ ::= {{ coq-equality decide equality. apply eq_value_name. }}
  | x :: :: Va
  %| < e1 , .. , en > :: :: ETuple
  %| e iv :: :: Proj
  %| id :: :: Id
  | new T @ r :: :: New
  %{{ coq (new ([[T]])) }}
  | null T @ r :: :: NullFn
  | isnull ( e ) :: :: isNull
  %{{ coq (isnull ([[e]])) }}
  | upregion ( e , r1 , .. , rn ) :: :: UpRegion
  %{{ coq (upregion [[e]] [[r1 .. rn]] )}}
  | downregion ( e , r1 , .. , rn ) :: :: DownRegion
  %{{ coq (downregion [[e]] [[r1 .. rn]] )}}
  | read ( e ) :: :: Read
  %{{coq (read ([[e]]))}}
  | read ( e1 , excl , e2 , e3 ) :: :: ReadE
  % {{ coq (reade ([[e1]]) excl ([[e2]]) ([[e3]]))}}
  | write ( e1 , e2 ) :: :: Write
  % {{ coq (write ([[e1]]) ([[e2]])) }}
  | reduce ( id , e1 , e2 ) :: :: Reduce
  % {{ coq (reduce ([[id]]) ([[e1]]) ([[e2]]))}}
  | reduceid ( l , e1 , e2 , e3 ) :: :: Reduceid
  % {{ coq (reduceid ([[l]]) ([[e1]]) ([[e2]]) ([[e3]]) )}}
  | newcolor r :: :: NewColor
  % {{ coq (newcolor ([[r]]))}}
  | color ( e1 , e2 , e3 ) :: :: Color
  %{{ coq (color ([[e1]]) ([[e2]])) }}
  | e1 + e2 :: :: IntOp
  %{{ coq IntOp [[e1]] [[e2]] }}
  | e1 lt e2 :: :: Comp
  %{{ coq Comp [[e1]] [[e2]] }}
  | let id : T =  e1 in e2 :: :: Let
  | if e1 then e2 else e3         ::  :: If         {{ com conditional }}
  | id [ r1 , .. , rn ] ( e1 , .. , em ) :: :: FuncCall
  % {{ coq (fncall ([[id]]) ([[r1 .. rn]]) ([[e1 .. em]]))}}
  | partition rp using e1 as r1 , .. , rn in e2 :: :: Part
  % {{ coq (partition ([[rp]]) ([[e1]]) ([[r1 .. rn]]) ([[e2]]))}}
  | pack e1 as T :: :: Pack
  % {{ coq (pack ([[e1]]) ([[T]])) }}
  | unpack e1 as id : T in e2 :: :: Unpack
  % {{ coq (unpack ([[e1]]) ([[id]]) ([[T]]) ([[e2]])) }}
  | function id [ r1 , .. , rn ] ( e1 , .. , em ) :: :: FuncDef
  | { function id1 rr1 ee1 , .. , function idn rrn een }  :: :: FuncDefList
  % {{ coq (fnlist ([[id1 rr1 ee1 .. idn rrn een]])) }}
  % | v :: :: Value
  % {{ coq [[v]] }}
  %| L :: :: Ls
  % {{ coq [[L]] }}
  % interesting how am I going to feed the context to the type here?
  | e : T :: :: TypedExpr
  | place :: :: PlaceHolder
  %| {function id1 [ r1 , .. , rn ]1 ( e1 , .. , em )1 , .. , function idn [ r1 , .. , rn ]n ( e1 , .. , em )n }  :: :: FuncDefList
  | bv :: :: Base1
  % {{ coq [[bv]] }}
  | iv :: :: Base2
  % {{ coq [[iv]] }}
  | < v1 , v2 > :: :: Tuple
  | null :: :: NullLoc
%{{ coq [] }}
  | l :: :: MemoryLoc
% {{ coq [[l]]}}
  | < < rho1 , .. , rhon , v  > > :: :: RegRelInst
%| S  :: :: Sthing
  | H :: :: HeapVal
%{{ coq [[H]]}}
  | K :: :: Kthing
%{{ coq [[K]]}}
  | true                         ::   :: True       {{ com constant true }}
  | false                         ::   :: False      {{ com constant false }}
  | 0 :: :: Zero
  % {{ coq O}}
  | S iv :: ::  Succ
  % {{ coq Datatypes.S [[iv]]}}

formula :: formula_ ::=  {{ com formulas }}
   |  judgement                       ::   :: judgement
          {{ com judgement }}
   |  ~ formula                     :: M :: not
          {{ com negated formula }}
          {{ tex \neg [[formula]] }}
          {{ coq ~([[formula]]) }}
   |  ( formula )                     :: M :: brackets
          {{ com bracketed }}
          {{ tex \left([[formula]]\right) }} {{ isa ([[formula]]) }}
          {{ coq [[formula]] }}
   |  ALL i . phi in P :: M :: AllP
          {{ com for all variables in domain of $[[P]]$ }}
           {{ tex \forall_[[i]]. [[phi]] \in [[P]] }}
           {{ coq               forall [[i]]:[[P]], [[phi]] }}
   |  ALL i . phi in Pst :: M :: AllPst
           {{ com for all variables in domain of $[[Pst]]$ }}
           {{ tex \forall_[[i]]. [[phi]] \in [[Pst]] }}
           {{ coq               forall [[i]]:[[Pst]], [[phi]] }}
   |  EX i . phi in P :: M :: Exists
           {{ com for all variables in domain of $[[P]]$ }}
           {{ tex \exists_[[i]]. [[phi]] \in [[P]] }}
           {{ coq               exists [[i]]:[[P]], [[phi]] }}
   |  ALL i . om in O :: M :: AllO
           {{ com for all variables in domain of $[[O]]$ }}
           {{ tex \forall_[[i]]. [[om]] \in [[O]] }}
           {{ coq               forall [[i]]:[[O]], [[om]] }}
   |  ALL i . om in Ost :: M :: AllOst
           {{ com for all variables in domain of $[[Ost]]$ }}
           {{ tex \forall_[[i]]. [[om]] \in [[Ost]] }}
           {{ coq               forall [[i]]:[[Ost]], [[om]] }}
   |  EX i . om in O :: M :: ExistsO
           {{ com for all variables in domain of $[[O]]$ }}
           {{ tex \exists_[[i]]. [[om]] \in [[O]] }}
           {{ coq               exists [[i]]:[[O]], [[om]] }}
   |  EX i . om in Ost :: M :: ExistsOst
           {{ com for all variables in domain of $[[Ost]]$ }}
           {{ tex \exists_[[i]]. [[om]] \in [[Ost]] }}
           {{ coq               exists [[i]]:[[Ost]], [[om]] }}
   |  ALL i . formula :: M :: AllF
           {{ com for all variables in $[[i]]$ and $[[formula]]$ }}
           {{ tex \forall_[[i]]. [[formula]] }}
           {{ coq               forall [[i]], [[formula]] }}
   |  EX formula1 . formula2 :: M :: ExistsF
           {{ com for all variables in $[[formula1]]$ and $[[formula2]]$ }}
           {{ tex \exists_[[formula1]]. [[formula2]] }}
           {{ coq               exists [[formula1]], [[formula2]] }}
   |  EX formula1 . formula2 WHERE formula3 :: M :: ExistsFW
           {{ com exists $[[formula1]]$ and $[[formula2]]$ where $[[formula3]]$ }}
           {{ tex \exists_[[formula1]]. [[formula2]] \text{ where } [[formula3]] }}
           {{ coq               exists [[formula1]], [[formula2]] }}
   | G ( id ) :: :: Lookup
           {{ com lookup }}
           {{ tex \[[G]]([[id]]) }}
           {{ coq               In [[id]] [[G]] }}
   | formula1 = formula2 :: :: Equality
           {{ com equality }}
           {{ tex [[formula1]] = [[formula2]] }}
           {{ coq [[formula1]] = [[formula2]] }}
   | formula1 /\ formula2 :: :: And
           {{ com equality }}
           {{ tex [[formula1]] \land [[formula2]] }}
           {{ coq [[formula1]] /\ [[formula2]] }}
   | BAND  i . formula :: M :: BigAnd
           {{ com and fold on $[[i]]$ and $[[formula]]$ }}
           {{ tex \bigwedge_[[i]]. [[formula]] }}
           {{ coq Band [[i]] [[formula]] }}
   | formula1 INTR formula2 :: M :: Intersect
          % {{ com intersection of [[formula1]] [[formula2]] }}
           {{ tex [[formula1]] \cap [[formula2]] }}
           {{ coq Intersection ([[formula1]]) ([[formula2]]) }}
   | formula1 UNION formula2 :: M :: Union
          % {{ com union of [[formula1]] [[formula2]] }}
           {{ tex [[formula1]] \cup [[formula2]] }}
           {{ coq Intersection [[formula1]] [[formula2]] }}
   | formula1 SUB formula2 :: M :: Subset
          % {{ com [[formula1]] is subset of [[formula2]] }}
           {{ tex [[formula1]] \subseteq [[formula2]] }}
           {{ coq subset [[formula1]] [[formula2]] }}
   | formula1 INS formula2 :: M :: In
          % {{ com [[formula1]] is subset of [[formula2]] }}
           {{ tex [[formula1]] \in [[formula2]] }}
           {{ coq subset [[formula1]] [[formula2]] }}
   | G , P , O -> T :: :: TypeImpl
           {{ com impl }}
           {{ tex [[G]],[[P]],[[O]] \rightarrow [[T]] }}
           {{ coq [[G]] /\ [[P]] /\ [[O]] -> [[T]] }}
   | G , P , Q -> T :: :: QthingImpl
           {{ com impl }}
           {{ tex [[G]],[[P]],[[Q]] \rightarrow [[T]] }}
           {{ coq [[G]] /\ [[P]] /\ [[Q]] -> [[T]] }}
  | r1 , .. , rn :: :: RegL
  {{ com region list }}
  | phi :: :: Perm
  {{ com phi }}
  {{ tex [[phi]] }}
  {{ coq [[phi]] }}
  | om :: :: omegas
  {{ com om }}
  {{ tex [[om]] }}
  {{ coq [[om]] }}
  | O :: :: Perms {{ coq [[O]] }}
  | P :: :: Phi {{ coq [[P]] }}
  | Pst :: :: PhiStar {{ coq [[Pst]] }}
  | P [ r1 / r1' , .. , rn / rn' ] :: :: PhiRepl
  | T [ r1 / r1' , .. , rn / rn' ] :: :: TypeRepl
  % fixme
  | M [ rho1 / r1' , .. , rhon / rn' ] :: :: MemRepl {{ coq ([[M]])}}
  | M [[ T ]] :: :: MemSem
  | M [[ Q ]] :: :: MemQ
  | domain ( S ) :: :: Domain
  | M ( r ) :: :: MemLookup
  | G [ r1 / r1' , .. , rn / rn' ] :: :: TypeContextRepl
  | G [ e1 / T1 , .. , en / Tn ] :: :: TypeReplRepl
  | G :: :: TypeContF
  | G [ T [ r1 / r1' , .. , rn / rn' ] / id ] :: :: TypeContextElement
  | O [ r1 / r1' , .. , rn / rn' ] :: :: CompRepl
  | regions_of ( G , T ) :: :: RegionsOf2
  | regions_of ( G , T1, T2 ) :: :: RegionsOf3
  | rs :: :: RegionsForm
  | T :: :: TypeForm {{ coq [[T]] }}
  | fns :: :: Fns {{ coq [[fns]] }}
  | S :: :: Ss {{ coq [[S]] }}
  | C :: :: Cs {{ coq [[C]] }}
  | M :: :: Ms {{ coq [[M]] }}
  | e :: :: Exprs {{ coq [[e]] }}
  % | v :: :: Vs {{ coq [[v]] }}
  | E :: :: Es {{ coq [[E]] }}
  | L :: :: Ls {{ coq [[L]] }}
  | </ ei = li // i IN n      /> :: :: ListComp

terminals :: terminals_ ::=
  | EX  ::   :: exists          {{ tex \exists }}
  | ALL ::   :: forall          {{ tex \forall }}
  | in                         ::   :: in              {{ tex \in }}
  | om                      ::   :: omega           {{ tex \omega }}
  | phi                        ::   :: phi             {{ tex \phi }}
  | rho                        ::   :: rho             {{ tex \rho }}
  | \/                         ::   :: lor             {{ tex \lor }}
  | /\                         ::   :: land            {{ tex \land }}
  | ~                          ::   :: neg             {{ tex \neg }}
  %| <                         ::   :: lt            {{ tex < }}
  | *                         ::   :: sep {{ tex * }}
  | <=                         ::   :: leq            {{ tex \leq }}
  | -->                        ::   :: longrightarrow {{ tex \longrightarrow }}
  | ->                         ::   :: rightarrow     {{ tex \rightarrow }}
  | =>                         ::   :: Rightarrow     {{ tex \Rightarrow }}
  | \                          ::   :: lambda         {{ tex \lambda }}
  | |->                        ::   :: mapsto         {{ tex \mapsto }}
  | |-                         ::   :: vdash          {{ tex \vdash }}
  | emptyC                      ::   :: varnothingC     {{ tex \varnothing }}
  | emptyO                      ::   :: varnothingO     {{ tex \varnothing }}
  | emptyR                      ::   :: varnothingR     {{ tex \varnothing }}
  | emptyP                      ::   :: varnothingP     {{ tex \varnothing }}
  | *                          ::   :: times          {{ tex \times }}
  | <:                         ::   :: subtype        {{ tex <: }}
  | <                          ::   :: langle         {{ tex \langle }}
  | >                          ::   :: rangle         {{ tex \rangle }}
  | lt                         ::   :: lt             {{ tex < }}
  | \\                         ::   :: Downarrow      {{ tex \Downarrow }}
  | state                      ::   :: sigma          {{ tex \sigma }}
  | G                          ::   :: Gamma          {{ tex \Gamma }}
  | E                          ::   :: varepsilon        {{ tex \varepsilon }}

embed {{ coq
Definition reads (_:e) := E_PlaceHolder.
Definition writes (_:e) := E_PlaceHolder.
Definition reduces (_:e) := E_PlaceHolder.
Definition read (_:e) := E_PlaceHolder.
Definition reade (_:e) := E_PlaceHolder.
Definition write (_ _:e) :=  E_PlaceHolder.
Definition reduce (_:id) (_ _:e) := E_PlaceHolder.
Definition mark_coherence (_:E) (_:M) (_:iv) := E_PlaceHolder.
Definition new (_:T) := E_PlaceHolder.
Definition newcolor (_:r) := E_PlaceHolder.
Definition color (_ _:e) := E_PlaceHolder.
Definition upregion (_:e) (_:list_r) := E_PlaceHolder.
Definition downregion (_:e) (_:list_r) := E_PlaceHolder.
Definition partition (_:r) (_:e) (_:list_r) (_:e) := E_PlaceHolder.
Definition pack (_:e) (_:T) := E_PlaceHolder.
Definition unpack (_:e)  (_:id) (_:T) (_:e) := E_PlaceHolder.
Definition fncall (_:id) (_:list_r) (_:list_e) := E_PlaceHolder.
Definition fnlist (_:list_id_rr_ee) := E_PlaceHolder.
(* FIXME: make this type correctly *)
Definition IntOp (_ _:e) := E_PlaceHolder.
Definition Comp (_ _:e) := E_PlaceHolder.
}}

subrules
  v <:: e

defns
Jtype :: '' ::= 

defn
G , P , O |- e : T :: :: typing :: T_ {{ com Typing }} by

G,P,O |- e1 : T@(r1,..,rn) [[:type1checks]]
% so what to do here? 
% ALL i . reads(ri) in Pst [[:readperm]]
----------------- :: Read
G,P,O |- read(e1) : T

G,P,O |- e1 : T@(r1,..,rn) [[:type1checks]]
G,P,O |- e2 : T [[:type2checks]]
%ALL i . writes(ri) in Pst [[:writeperm]]
----------------- :: Write
G,P,O |- write(e1,e2) : T@(r1,..,rn)

% potentially need to do a fix here
% {(e1:T1),(e2:T2)},emptyP,emptyO -> T1 [[:impl]]
G,P,O |- e1 : T1@(r1,..,rn) [[:type1checks]]
G,P,O |- e2 : T2 [[:type2checks]]
% ALL i . reducesid(ri) in Pst [[:regionscanreduce]]
----------------- :: Reduce
G,P,O |- reduce(id,e1,e2) : T1@(r1,..,rn)


----------------- :: New
G,P,O |- new T@r : T@r

G,P,O |- e : T@(r1',..,rk') [[:renamedregion]]
%ALL i . EX j . ri' <= rj in Ost [[:alwaysaless]]
----------------- :: UpRgn 
G,P,O |- upregion(e1,r1,..,rn) : T@(r1,..,rn)

G,P,O |- e : T@(r1',..,rk') [[:haverenamed]]
----------------- :: DnRgn 
G,P,O |- downregion(e, r1,..,rn) : T@(r1,..,rn)

----------------- :: NewColor
G,P,O |- newcolor r : coloring(r)

G,P,O |- e1 : coloring(r) [[:type1checks]]
G,P,O |- e2 : T@r [[:type2checks]]
G,P,O |- e3 : int [[:type3checks]]
----------------- :: Color
G,P,O |- color(e1,e2,e3) : coloring(r)

G,P,O |- e1 : coloring(rp) [[:firstargcoloring]]
% (O' = O) /\ ((BAND i . ri <= rp) /\ (BAND j. ri * rj)) [[:everythingless]]
G,P,O' |- e2 : T [[:type2checks]]
%(({r1,..,rk}) INTR regions_of(G,T)) = emptyR [[:allregionsempty]]
----------------- :: Partition
G,P,O |- partition rp using e1 as r1,..,rk in e2: T

% is this necessary? need to think about this.
% T1 = EX r1',..,rk'.T2 WHERE O1 [[:existstype]]
% O1[r1/r1',..,rk/rk'] SUB O' [[:renamedsub]]
G,P,O |- e1 : T2[r1/r1',..,rk/rk'] [[:type1checks]]
----------------- :: Pack
G,P,O |- pack e1 as T1:T1
%G,P,O |- pack e1 as T1[r1,..,rk]:T1

% T1 = exists r1',..,rk'.T2 where O
% Is this necessary?
% T1 = EX r1',..,rk'.T2 WHERE O1 [[:typeexists]]
G,P,O |- e1 : T1 [[:type1checks]]
%G' = G[T2[r1/r1',..,rk/rk']/id] [[:renamedtypecontext]]
%O' = (O UNION O1[r1/r1',..,rk/rk']) [[:renamedpermissions]]
G',P,O' |- e2 : T3 [[:type2checks]]
%({r1,..,rk} INTR regions_of(G,T1,T3)) = emptyR [[:allregionsempty]]jjj
----------------- :: UnPack
G,P,O |- unpack e1 as id: T1 in e2:T3
%G,P,O |- unpack e1 as id: T1[r1,..,rk] in e2:T3

%{(e1:T1),..,(en:Tn)}
% G,P',Q' -> T [[:impl]]
% G,P,O |- e1 : T[r1/r1',..,rk/rk'] [[:typerename1check]]
%P'[r1/r1',..,rk/rk'] SUB Pst  [[:renamedsub]]
----------------- :: Call
G,P,O |- id[r1,..,rk](e1,..,en) : T

%Tr[r1/r1',..,rk/rk'] }}
% really there isn't much going on here.
% it's just a list of functions.
% and you are saying that. for each context the memory regions typecheck
%{{ for 1 <= i <= p,

% so this is actually a list of all these things.
% which means that I need to define a subset

%{(e1:T1),..,(en:Tn)}
%trip1,..,tripp
% G,P',Q' -> T [[:impl]]
% O1[r1/r1',..,rk/rk'] SUB O' [[:replsubset]]
% G = G[e1/T1,..,em/Tm] [[:renamedprog]]
----------------- :: Program
G,P,O |- {function id1 [r1,..,rk] (e1,..,em),..,function idn [r1,..,rk] (e1,..,em)} : T

defns
 Jop :: '' ::=

defn
M , L , H , S , C |- e |-> v , E  :: :: eval :: E {{ com Evaluation }} by

------ :: Va
M,L,H,S,C |- x |-> v, E

% M == r to rho mappings
% L == locals
% H == heaps and types
% E == dynamic memory trace
% S == clobber semantics
M,L,H,S,C |- e |-> l, E [[:prodvalue]]
%S' = apply(S,E) [[:apply]]
%~ (l INS C) [[:memnotclobber]]
------------------------------------------------- :: Read1
M,L,H,S,C |- read(e) |-> v, E
%++[read(l,excl,v,0)]
%M,L,H,S,C |- read(e) |-> S'(l), E++[read(l,excl,v,0)] 

M,L,H,S,C |- e |-> l, E [[:prodvalue]]
% S' = apply(S,E) [[:apply]]
------------------------------------------------- :: Read2
M,L,H,S,C |- read(e) |-> H(l), E
%++[read(l,excl,v,0)] 

M,L,H,S,C |- e1 |-> l, E [[:prodvalue]]
M,L,H,S,C |- e2 |-> l, E [[:prodvalue]]
M,L,H,S,C |- e3 |-> l, E [[:prodvalue]]
% S' = apply(S,E) [[:apply]]
------------------------------------------------- :: ReadE
M,L,H,S,C |- read(e1, excl, e2, e3) |-> v, E

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
% S' = apply(S,E1) [[:apply]]
M,L,H,S',C |- e2 |-> v, E2 [[:prod2value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Write
M,L,H,S,C |- write(e1,e2) |-> l, E
%++[read(l,excl,v,0)] 

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
% S' = apply(S,E1) [[:apply]]
M,L,H,S',C |- e2 |-> v, E2 [[:prod2value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Reduce
M,L,H,S,C |- reduce(id,e1,e2) |-> l, E
%++[reduceid(l,excl,v,0)]

M,L,H,S,C |- l |-> v1, E1 [[:prod1value]]
% S' = apply(S,E1) [[:apply]]
M,L,H,S',C |- e1 |-> v2, E2 [[:prod2value]]
M,L,H,S',C |- e2 |-> v3, E3 [[:prod3value]]
M,L,H,S',C |- e3 |-> v4, E3 [[:prod3value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: ReduceId
M,L,H,S,C |- reduceid(l,e1,e2,e3) |-> v, E

----------------- :: Null
M,L,H,S,C |- null |-> null, []

% l INS M(r) [[:meminmem]]
%~(l INS domain(S)) [[:memindom]]
%H(l) = M[[T]] [[:heapeqmemtype]]

----------------- :: New
M,L,H,S,C |- new T@r |-> l, []

----------------- :: NullTrue
M,L,H,S,C |- null T@nullr |-> true, []

~(T@r = T@nullr)
----------------- :: NullFalse
M,L,H,S,C |- null T@r |-> false, []

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
l = null
----------------- :: IsNullTrue
M,L,H,S,C |- isnull(l) |-> true, []

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
~(l = null)
----------------- :: IsNullFalse
M,L,H,S,C |- isnull(l) |-> false, []

M,L,H,S,C |- e |-> v, E [[:prodvalue]]
------------------------------------------------- :: UpRgn
M,L,H,S,C |- upregion(e,r1,..,rn) |-> v, E

M,L,H,S,C |- e |-> v, E [[:prodvalue]]
% EX i. (l INS M(ri)) [[:inmem]]
------------------------------------------------- :: DnRgn1
M,L,H,S,C |- downregion(e,r1,..,rn) |-> l, E

M,L,H,S,C |- e |-> v, E [[:prodvalue]]
% ~(l INS M(ri)) [[:meminri]]
------------------------------------------------- :: DnRgn2
M,L,H,S,C |- downregion(e,r1,..,rn) |-> null, E

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
% S' = apply(S,E1) [[:apply1]]
M,L,H,S',C |- e2 |-> v, E2 [[:prod2value]]
% S'' = apply(S',E2) [[:apply2]]
M,L,H,S'',C |- e3 |-> v, E3 [[:prod3value]]
% need setbuilder notation here
% K' = {(l,v)} UNION {(li,vi)}
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Color
M,L,H,S,C |- color(e1,e2,e3) |-> K', E'


----------------- :: NewColor
M,L,H,S,C |- newcolor r |-> K,[]

M,L,H,S,C |- e1 |-> K, E1 [[:prod1value]]
% { rhoi ,
%M' = M[rho1/r1,..,rhok/rk] [[:memreplace]]
% S' = apply(S,E1) [[:apply]]
M,L,H,S',C |- e2 |-> v, E2 [[:prod2value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Partition
M,L,H,S,C |- partition rp using e1 as r1,..,rk in e2 |-> l, E'

M,L,H,S,C |- e1 |-> K, E1 [[:prod1value]]
% { rhoi ,
% v' = <<rho1,..,rhok,v>> [[:valismem]]
------------------------------------------------- :: Pack
M,L,H,S,C |- pack e1 as T1 |-> v', E
%M,L,H,S,C |- pack e1 as T1[r1,..,rk] |-> v', E

M,L,H,S,C |- e1 |-> <<rho1,..,rhok,v>>,E1 [[:prod1memval]]
%M' = M[rho1/r1,..,rhok/rk]  [[:memreplace]]
L'=L[v1/id] [[:lreplace]]
% S'=apply(S,E1) [[:apply]]
M',L',H,S',C |- e2 |-> v, E2 [[:prod2value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Unpack
M,L,H,S,C |- unpack e1 as id:T1 in e2 |-> v2, E'
%M,L,H,S,C |- unpack e1 as id:T1[r1,..,rk] in e2 |-> v2, E'


%M,L,H,S,C |- e1 |-> v1,E1 [[:prod1value]]
% S1 = apply(S,E1) [[:apply]]
%valid_interleave(S,C,E',E1,..,En) [[:validinterleave]]
% need a way of making a synonym here
%function id[r1',..,rk'](a1:T1,..,an:Tn),P',Q':Tr = en
% function id[r1',..,rk'](e1:T1,..,en:Tn),P',Q':Tr = en [[:funcdef]]
%+1
%M' = M[rho1/r1,..,rhok/rk] [[:memreplace]]
% fixme
L'=L[(e1,v1),..,(en,vn)] [[:memreplace]]
% S'=apply(S,E') [[:apply]]
%</ ei = li // i IN m      />  
%C' = C UNION {l: EX rho. l IN rho /\ (atomic(rho) IN M'[[Q']] \/ simult(rho) IN M'[[Q']])}
%M',L',H,S',C' |- en+1 |-> vn+1, En+1
%M',L',H,S',C' |- en |-> vn, En [[:nthvalue]]
%En+1'=mark_coherence(En+1,M'[[Q']],taskid)
% E'=mark_coherence(E,M'[[Q']],i) [[:makecoherence]]
%x = taskid fresh [[:freshid]]
% valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- ::  Call
M,L,H,S,C |- id[r1,..,rk](e1,..,en) |-> vn, E''
%M,L,H,S,C |- id[r1,..,rk](e1,..,en) |-> vn+1, E''


M,L,H,S,C |- e1 |-> v1,E1 [[:prod1value]]
M,L,H,S,C |- e2 |-> v2,E2 [[:prod2value]]
%v = v1+v2  [[:result]]  {{ coq [[v]] = (IntOp [[v1]] [[v2]]) }}
------------------------------------------------- :: IntOp 
M,L,H,S,C |- e1+e2 |-> v, E

M,L,H,S,C |- e1 |-> v1,E1 [[:prod1value]]
M,L,H,S,C |- e2 |-> v2,E2 [[:prod2value]]
%v = v1 lt v2 [[:result]]
------------------------------------------------- :: Comp 
M,L,H,S,C |- e1 lt e2 |-> v, E

% need to have a way of doing let bindings 
M,L,H,S,C |- e1 |-> v1,E1 [[:prod1value]]
% 
M,L,H,S,C |- e2 |-> v2,E2 [[:prod2value]]
L'=L[v1/id]
------------------------------------------------- :: Let 
M,L,H,S,C |- let id : T = e1 in e2 |-> v, E


M,L,H,S,C |- e1 |-> true,E1 [[:prod1value]]
M,L,H,S,C |- e2 |-> v,E1 [[:prod1value]]
------------------------------------------------- :: IfTrue
M,L,H,S,C |- if e1 then e2 else e3 |-> v, E

M,L,H,S,C |- e1 |-> false,E1 [[:prod1value]]
M,L,H,S,C |- e3 |-> v,E2 [[:prod2value]]
------------------------------------------------- :: IfFalse
M,L,H,S,C |- if e1 then e2 else e3 |-> v, E

% so you need to need to use it to add to the definitions.
% so what does a function def need to evaluate?
L'=L[ id[ r1 , .. , rn ]( e1 , .. , em )/id]
------------------------------------------------- :: FuncDef
M,L,H,S,C |- function id [ r1 , .. , rn ] ( e1 , .. , em ) |-> v, E

% need to make this work.
------------------------------------------------- :: FuncDefList
M,L,H,S,C |-  { function id1 rr1 ee1 , .. , function idn rrn een } |-> v, E

% constants
M,L,H,S,C |- e |-> v, E
-------------------------- :: TypedExpr
M,L,H,S,C |- e : T |-> v, E

-------------------- :: Place
M,L,H,S,C |- place |-> place, E

----------------------- :: bv 
M,L,H,S,C |- bv |-> bv, E

---------------------- :: iv 
M,L,H,S,C |- iv |-> iv, E

--------------------- :: Tuple
M,L,H,S,C |- <v1,v2> |-> <v1,v2>, E

------------------ :: NullLoc
M,L,H,S,C |- null |-> null, E

------------------ :: MemoryLoc
M,L,H,S,C |- l |-> l, E

---------------------- :: RegRelInst
M,L,H,S,C |-  <<rho1,..,rhon,v>> |->  <<rho1,..,rhon,v>>, E

---------------- :: HeapVal
M,L,H,S,C |- H |-> H, E

---------------- :: Kthing
M,L,H,S,C |- K |-> K, E

embed {{ coq
Notation "G , P , O |- e : T ":= (typing G P O e T) (no associativity, at level 99). 
Notation "M , L , H , S , C |- e |-> v , E" := (eval M L H S C e v E) (no associativity, at level 99).

(* need theorem to prove that all top level e there is a typing rule *)

Theorem preservation : forall (e5:e) (t:T) (E:E) (M:M) (L:L) (H:H) (S:Clobber) (C:C) (T:T),
    exists v,
      eval M L H S C e5 v E ->
      typing G_EmptyContext P_EmptyPriv O_EmptyConstraint e5 T  ->
      exists G P Omega T, typing G P Omega v T.
Proof.
  intros.
  eexists.
  intros.
  destruct e5; repeat (inversion H2;
  exists G_EmptyContext;
  exists  P_EmptyPriv;
  exists O_EmptyConstraint;
  exists T0;
  try (apply H2 || simpl;assumption || rewrite <- H9 at 1; rewrite H4;  assumption ) ).

  rewrite H5.
  assumption.
  rewrite H3.
  assumption.
Qed.


Theorem progress : forall (e5:e) (t:T) (M:M) (H:H) (S:Clobber) (C:C) (T1 T2:T),
     exists E L v,
     typing G_EmptyContext P_EmptyPriv O_EmptyConstraint e5 T1  ->
       typing G_EmptyContext P_EmptyPriv O_EmptyConstraint v T2  ->
       eval M L H S C e5 v E.
Proof.
  intros.
  induction e5.
  - (* Va *)
  (*  eexists. *)
  exists E_NullE.
  exists L_Nil.
  exists E_PlaceHolder.
  intros.
  apply EVa.
  reflexivity.
  reflexivity.
  reflexivity.
  (* are memory locations some or none? *)
  - (* New *)
   (* eexists. *)
  exists (E_NullE).
  exists L_Nil.
  exists (E_MemoryLoc ML_NilLoc).
  intros.
  apply ENew.
  reflexivity.
  - (* NullFn *)
    destruct r5.
    * (* NullFn True *)
      (* eexists. *)

      exists (E_NullE).
      exists L_Nil.
      exists (E_Base1 bv_True).
      intros.
      apply ENullTrue.
      reflexivity.

    *   (* NullFn False *)
      (* eexists. *)
      exists (E_NullE).
      exists L_Nil.
      exists (E_Base1 bv_False).
      intros.
      apply ENullFalse.
      reflexivity.
      contradiction.
  - (* IsNull *)
    repeat eexists.
    intros.
    destruct e5; try (inversion H1).
  - (* UpRgn *)
    exists (E_NullE).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    apply EUpRgn.
    inversion H2.
    reflexivity.
    inversion H2.
    reflexivity.
    reflexivity.
  - (* DnRgn *)
    exists (E_NullE).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    inversion H2.
  - (* Read *)
    exists (E_NullE).
    exists L_Nil.
    repeat eexists.
    intros.
    (* how would I prove this in real life? should just work with rule2. *)
    (* the problem is that the inductive hypothesis is messed up *)
    apply ERead2.
    (* so we are proving that it always returns a memory location *)
    (* the inductive hypothesis should be that anything that typechecks for read
       so anything that any expression that can evaluate.
       Anything that doesn't type will contradict (If I do this right)
     *)
    destruct e5; inversion H2.
    reflexivity.
    inversion H2.
    reflexivity.
    (* FIXME: unimplemented *)
  - (* ReadE *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EReadE with (l5:=ML_NilLoc).
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
  - (* Write *) 
    exists (E_NullE).
    exists L_Nil.
    repeat eexists.
    intros.
    apply EWrite with (E1:=E_NullE) (Clobber':=S_Null) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE).
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    reflexivity.
    inversion H2.
    inversion H2.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Reduce *)
    exists (E_NullE).
    exists L_Nil.
    repeat eexists.
    intros.
    apply EReduce with (E1:=E_NullE) (Clobber':=S_Null) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE).
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    reflexivity.
    inversion H2.
    inversion H2.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Reduceid *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    repeat eexists.
    intros.
    apply EReduceId with (E1:=E_NullE) (Clobber':=S_Null) (v1:=(E_MemoryLoc ML_NilLoc)) (v2:=(E_MemoryLoc ML_NilLoc)) (v3:=(E_MemoryLoc ML_NilLoc)) (v4:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE) (E3:=E_NullE).
    inversion H1.
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* NewColor *)
    exists (E_NullE).
    exists L_Nil.
    Variable x0:K.
    exists (E_Kthing x0).
    intros.
    apply ENewColor.
    reflexivity.
  - (* Color *) 
    exists (E_NullE).
    exists L_Nil.
    exists (E_Kthing x0).
    intros.
    apply EColor with (E1:=E_NullE) (Clobber':=S_Null)  (Clobber'':=S_Null) (l5:=ML_NilLoc) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE) (E3:=E_NullE).
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    destruct e5_3; inversion H2.
    reflexivity.
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    destruct e5_3; inversion H2.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* IntOp *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EIntOp with  (E1:=E_NullE) (E2:=E_NullE) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    inversion H1.
    inversion H1.
    (* TODO: fill out IntOp *)
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Comp *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EComp with  (E1:=E_NullE) (E2:=E_NullE) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    inversion H1.
    inversion H1.
    (* TODO: fill out Comp *)
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Let *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply ELet with  (E1:=E_NullE) (E2:=E_NullE) (L':=L_Nil) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    destruct e5_1; inversion H1.
    destruct e5_1; inversion H2.
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  (* TODO: fill out substition *)
    destruct id5; inversion H1.
  - (* If *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    destruct e5_1; inversion H1.
  - (* Call *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H2.
  - (* Partition *)
     exists (E_NullE).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    (* TODO: Get this unifying *)
    apply EPartition with (E1:=E_NullE) (Clobber':=S_Null) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE) (K5:=K_Null) (p:=0).
    inversion H1.
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    induction l0.
    simpl.
    inversion H2.
    simpl.
    inversion H2.
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* Pack *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EPack with (E1:=E_NullE) (K5:=K_Null).
    Variable xl : list_r.
    apply xl.
    destruct e5; inversion H2.
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* Unpack *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EUnpack with (r_rho_list:=Nil_list_r_rho) (v_5:=E_PlaceHolder) (E1:=E_NullE) (E2:=E_NullE)  (Clobber':=S_Null) (L':=L_Nil) (v1:=E_PlaceHolder) (M':=M_Nil).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* FuncDef *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EFuncDef with (L':=L_Nil).
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    (* TODO: list assumption needs cleanup *)
    induction l1.
    simpl.
    apply Forall_nil.
    apply Forall_cons.
    inversion H2.
    apply IHl1.
    inversion H1.
    (* TODO: really do the environment *)
    destruct id5; inversion H1.
  - (* FundDefList *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EFuncDefList.
    reflexivity.
    reflexivity.
    reflexivity.
    induction l0.
    simpl.
    apply Forall_nil.
    apply Forall_cons.
    inversion H2.
    apply IHl0.
    inversion H2.
  - (* TypedExpr *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply ETypedExpr.
    reflexivity.
    inversion H1.
    reflexivity.
    reflexivity.
    destruct e5; inversion H2.
  - (* PlaceHolder *)
    (* TODO: remove when no longer necessary *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H1.
  - (* BoolVal *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    destruct bv5; inversion H1.
  - (* IntVal *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    destruct iv5; inversion H1.
  -  (* Tuple *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    apply ETuple.
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
  - (* NullLoc *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* MemoryLoc *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* RegRelInst *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* HeapVal *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
    (* TODO: Understand this and name it correctly *)
  - (* Kthing *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* True *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* False *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* Zero *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* Succ *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
    Variable x1:E.
    Variable x2:L.
    Variable x3:e.
    Variable x4:l.
    Unshelve.
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
Qed.
}}