% contributions:
%  full proof of definitional equality.
%  full specification of core legion.
%  proofs of progress and preservation

%embed {{ tex
%\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
%\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}
%}}

embed {{ coq
Require Import Nat.
Require Import ListSet.
Import ListNotations.
}}

metavar termvar, x ::= {{ com term variable }}
{{ isa string}} {{ coq nat}} {{ hol string}} {{ coq-equality }}
{{ ocaml int}} {{ lex alphanum}} {{ tex \mathit{[[termvar]]} }}

indexvar index, i, j, k, n, m, p  ::= {{ isa num }} {{ coq nat }} {{ hol num }}
grammar

r :: r_ ::= {{ coq-equality }}
| nullr :: :: Null
| notnullr :: :: NotNull

rr :: rr_ ::= {{ coq-equality }}
| [ r1 , .. , rn ] :: :: Rlist

l :: ML_ ::= {{ coq-equality }}
| nil :: :: NilLoc

C :: C_ ::=
%| e1 , .. , en :: :: CList

G {{ tex \Gamma }} :: G_ ::= {{ coq-equality }}
| { ( e1 : T1 ) , .. , ( en : Tn ) } :: :: Context
| emptyC :: :: EmptyContext

O {{ tex \Omega }} {{ coq Omega }} :: O_ ::= {{ coq-equality }}
| { om1 , .. , omn } :: :: RegionConstraint
| emptyO :: :: EmptyConstraint

Ost {{ tex \Omega^* }} :: Ost_ ::= {{ coq-equality }}
| { om1 , .. , omn } :: :: RegionConstraintSt
| emptyOst :: :: EmptyConstraintSt

rs :: O_ ::= {{ coq-equality }}
| { r1 , .. , rn } :: :: Regions
| emptyR :: :: EmptyRegion


om {{ tex \omega }} :: o_ ::= {{ coq-equality }}
| r1 <= r2 :: :: Subregion
| r1 * r2 :: :: Disjointness

P {{ tex \Phi }} :: P_ ::= {{ coq-equality }} 
| { phi1 , .. , phin } :: :: Priv
| emptyP :: :: EmptyPriv

Pst {{ tex \Phi^* }} :: Pst_ ::= {{ coq-equality }} 
| { phi1 , .. , phin } :: :: PrivSt
| emptyPst :: :: EmptyPrivSt


phi {{ tex \phi }} :: p_ ::= {{ coq-equality }} 
| reads ( r )  :: :: Reads {{coq (reads [[r]])}}
| writes ( r ) :: :: Writes {{coq (writes [[r]])}}
| reducesid ( r ) :: :: Reduces {{coq (reduces [[r]])}}

Q :: Q_ ::= {{ coq-equality }} 
| { q1 , .. , qn } :: :: CoherenceModes

q :: q_ ::= {{ coq-equality }} 
| atomic ( r ) :: :: Atomic
| simult ( r ) :: :: Simultaneous

M :: M_ ::= {{ coq-equality }} 
| nullm :: :: Null
| M [[ Q ]] :: :: Qexpr

L :: L_ ::= {{ coq-equality }} 
| nil :: :: Nil
| L [ ( e1 , v1 ) , .. , ( en , vn ) ]  :: :: LMapping
| L [ e / id ] :: :: LRepl

K :: K_ ::= {{ coq-equality }}  
| nullk :: :: Null

H :: H_ ::= {{ coq-equality }}
| H ( l ) :: :: Hl

S {{ coq Clobber }} :: S_ ::= {{ coq-equality }}
| nullc :: :: Null 

 
%C :: C_ ::=
%| nullcc :: :: Null

emem :: em_ ::= {{ coq-equality }}
| read ( e1 , excl , e2 , e3 ) :: :: ReadE
| write ( e1 , excl , e2 , e3 ) :: :: WriteE 
| reduceid ( e1 , excl , e2 , e3 ) :: :: ReduceIdE

E :: E_ ::= {{ coq-equality }}
| [ ] :: :: NullE
| E ++ [ emem ] :: :: Append {{ coq ([[E]]) ++ ([[emem]]) }}

rho {{ tex \rho }} :: rho_ ::=


v :: v_ ::= {{ coq-equality }}
| bv :: :: Base1 {{ coq [[bv]] }}
| iv :: :: Base2 {{ coq [[iv]] }}
| < v1 , v2 > :: :: Tuple
| null :: :: NullLoc
%{{ coq [] }}
| l :: :: MemoryLoc
% {{ coq [[l]]}}
%| { ( l1 , iv ) , .. , ( ln , iv ) } :: :: Coloring
| < < rho1 , .. , rhon , v  > > :: :: RegRelInst
%| S  :: :: Sthing
| H :: :: HeapVal
%{{ coq [[H]]}}
| K :: :: Kthing
%{{ coq [[K]]}}
  | place :: :: PlaceHolder


bv :: bv_ ::= {{ coq-equality }}

  | true                         ::   :: True       {{ com constant true }}
  | false                         ::   :: False      {{ com constant false }}

iv :: iv_ ::= {{ coq-equality }}
%| 0 :: :: Zero
%{{ coq O}}
%| S iv :: ::  Succ
%{{ coq Datatypes.S [[iv]]}}

fresh :: ti_ ::= {{ coq-equality }}
| iv :: :: TaskNum {{ coq [[iv]] }}


ee :: ee_ ::=  {{ coq-equality }}
| ( e1 , .. , en ) :: :: Elist

id :: id_ ::=  {{ coq-equality }}

T :: T_ ::= {{ coq-equality }}
%{{ coq-equality decide equality. apply eq_value_name. }}
  | bool :: :: Num
  | int :: :: Va
  | < T1 , .. , Tn > :: :: Tuple
  | T @ r :: :: PointerOne
  | T @ ( r1 , .. , rn ) :: :: Pointer
  | T [ r1 , .. , rn ] :: :: TypeList
  | T [ r1 / r1' , .. , rn / rn' ] :: :: TypeRepl
  | coloring ( r ) :: :: RegionColoring
  | exists r1 , .. , rn . ( T1 , .. , Tm ) , P , Q -> Tr ::  :: Functions

fns :: '' ::= {{ coq-equality }}
|    apply ( S , E ) :: :: apply
|    valid_interleave ( S , C , E1 , .. , En ) :: :: valid_interleave
|    taskid fresh :: :: taskid
|    mark_coherence ( E , M , taskid ) :: :: MarkCoherence {{coq (mark_coherence ([[E]]) ([[M]]) taskid) }}

excl :: excl_ ::= {{ coq-equality }}

e :: E_ ::= {{ coq-equality }}
  | x :: :: Va
  %| < e1 , .. , en > :: :: ETuple
  %| e iv :: :: Proj
  %| id :: :: Id
  | new T @ r :: :: New
  %{{ coq (new ([[T]])) }}
  | null T @ r :: :: NullFn
  | isnull ( e ) :: :: isNull
  %{{ coq (isnull ([[e]])) }}
  | upregion ( e , r1 , .. , rn ) :: :: UpRegion
  %{{ coq (upregion [[e]] [[r1 .. rn]] )}}
  | downregion ( e , r1 , .. , rn ) :: :: DownRegion
  %{{ coq (downregion [[e]] [[r1 .. rn]] )}}
  | read ( e ) :: :: Read
  %{{coq (read ([[e]]))}}
  % {{ coq (reade ([[e1]]) excl ([[e2]]) ([[e3]]))}}
  | write ( e1 , e2 ) :: :: Write
  % {{ coq (write ([[e1]]) ([[e2]])) }}
  | reduce ( id , e1 , e2 ) :: :: Reduce
  % {{ coq (reduce ([[id]]) ([[e1]]) ([[e2]]))}}
  | reduceid ( l , e1 , e2 , e3 ) :: :: Reduceid
  % {{ coq (reduceid ([[l]]) ([[e1]]) ([[e2]]) ([[e3]]) )}}
  | newcolor r :: :: NewColor
  % {{ coq (newcolor ([[r]]))}}
  | color ( e1 , e2 , e3 ) :: :: Color
  %{{ coq (color ([[e1]]) ([[e2]])) }}
  | e1 + e2 :: :: IntOp
  %{{ coq IntOp [[e1]] [[e2]] }}
  | e1 lt e2 :: :: Comp
  %{{ coq Comp [[e1]] [[e2]] }}
  | let id : T =  e1 in e2 :: :: Let
  | if e1 then e2 else e3         ::  :: If         {{ com conditional }}
  | id [ r1 , .. , rn ] ( e1 , .. , em ) :: :: FuncCall
  % {{ coq (fncall ([[id]]) ([[r1 .. rn]]) ([[e1 .. em]]))}}
  | partition rp using e1 as r1 , .. , rn in e2 :: :: Part
  % {{ coq (partition ([[rp]]) ([[e1]]) ([[r1 .. rn]]) ([[e2]]))}}
  | pack e1 as T :: :: Pack
  % {{ coq (pack ([[e1]]) ([[T]])) }}
  | unpack e1 as id : T in e2 :: :: Unpack
  % {{ coq (unpack ([[e1]]) ([[id]]) ([[T]]) ([[e2]])) }}
  | function id [ r1 , .. , rn ] ( e1 , .. , em ) :: :: FuncDef
  | { function id1 rr1 ee1 , .. , function idn rrn een }  :: :: FuncDefList
  % {{ coq (fnlist ([[id1 rr1 ee1 .. idn rrn een]])) }}
  % | v :: :: Value
  % {{ coq [[v]] }}
  %| L :: :: Ls
  % {{ coq [[L]] }}
  % interesting how am I going to feed the context to the type here?
  | e : T :: :: TypedExpr
  | place :: :: PlaceHolder
  %| {function id1 [ r1 , .. , rn ]1 ( e1 , .. , em )1 , .. , function idn [ r1 , .. , rn ]n ( e1 , .. , em )n }  :: :: FuncDefList
  | bv :: :: Base1
  % {{ coq [[bv]] }}
  | iv :: :: Base2
  % {{ coq [[iv]] }}
  | < v1 , v2 > :: :: Tuple
  | null :: :: NullLoc
%{{ coq [] }}
  | l :: :: MemoryLoc
% {{ coq [[l]]}}
  | < < rho1 , .. , rhon , v  > > :: :: RegRelInst
%| S  :: :: Sthing
  | H :: :: HeapVal
%{{ coq [[H]]}}
  | K :: :: Kthing
%{{ coq [[K]]}}
  | true                         ::   :: True       {{ com constant true }}
  | false                         ::   :: False      {{ com constant false }}
  | 0 :: :: Zero
  % {{ coq O}}
  | S iv :: ::  Succ
  % {{ coq Datatypes.S [[iv]]}}

formula :: formula_ ::=  {{ com formulas }}
   |  judgement                       ::   :: judgement
          {{ com judgement }}
   |  ~ formula                     :: M :: not
          {{ com negated formula }}
          {{ tex \neg [[formula]] }}
          {{ coq (not ([[formula]])) }}
   |  ( formula )                     :: M :: brackets
          {{ com bracketed }}
          {{ tex \left([[formula]]\right) }} {{ isa ([[formula]]) }}
          {{ coq [[formula]] }}
   |  ALL i . phi in P :: M :: AllP
          {{ com for all variables in domain of $[[P]]$ }}
           {{ tex \forall_[[i]]. [[phi]] \in [[P]] }}
           {{ coq               forall [[i]]:[[P]], [[phi]] }}
   |  ALL i . phi in Pst :: M :: AllPst
           {{ com for all variables in domain of $[[Pst]]$ }}
           {{ tex \forall_[[i]]. [[phi]] \in [[Pst]] }}
           {{ coq               forall [[i]]:[[Pst]], [[phi]] }}
   |  EX i . phi in P :: M :: Exists
           {{ com for all variables in domain of $[[P]]$ }}
           {{ tex \exists_[[i]]. [[phi]] \in [[P]] }}
           {{ coq               exists [[i]]:[[P]], [[phi]] }}
   |  ALL i . om in O :: M :: AllO
           {{ com for all variables in domain of $[[O]]$ }}
           {{ tex \forall_[[i]]. [[om]] \in [[O]] }}
           {{ coq               forall [[i]]:[[O]], [[om]] }}
   |  ALL i . om in Ost :: M :: AllOst
           {{ com for all variables in domain of $[[Ost]]$ }}
           {{ tex \forall_[[i]]. [[om]] \in [[Ost]] }}
           {{ coq               forall [[i]]:[[Ost]], [[om]] }}
   |  EX i . om in O :: M :: ExistsO
           {{ com for all variables in domain of $[[O]]$ }}
           {{ tex \exists_[[i]]. [[om]] \in [[O]] }}
           {{ coq               exists [[i]]:[[O]], [[om]] }}
   |  EX i . om in Ost :: M :: ExistsOst
           {{ com for all variables in domain of $[[Ost]]$ }}
           {{ tex \exists_[[i]]. [[om]] \in [[Ost]] }}
           {{ coq               exists [[i]]:[[Ost]], [[om]] }}
   |  ALL i . formula :: M :: AllF
           {{ com for all variables in $[[i]]$ and $[[formula]]$ }}
           {{ tex \forall_[[i]]. [[formula]] }}
           {{ coq               forall [[i]], [[formula]] }}
   |  EX formula1 . formula2 :: M :: ExistsF
           {{ com for all variables in $[[formula1]]$ and $[[formula2]]$ }}
           {{ tex \exists_[[formula1]]. [[formula2]] }}
           {{ coq               exists [[formula1]], [[formula2]] }}
   |  EX formula1 . formula2 WHERE formula3 :: M :: ExistsFW
           {{ com exists $[[formula1]]$ and $[[formula2]]$ where $[[formula3]]$ }}
           {{ tex \exists_[[formula1]]. [[formula2]] \text{ where } [[formula3]] }}
           {{ coq               exists [[formula1]], [[formula2]] }}
   | formula1 INSI formula2 :: :: SetMember
           {{ com $[[formula1]]$ is in $[[formula2]]$ }}
           {{ tex [[formula1]] \in [[formula2]] }}
           {{ coq In [[formula1]] [[formula2]] }}
   | G ( id ) :: :: Lookup
           {{ com lookup }}
           {{ tex \[[G]]([[id]]) }}
           {{ coq               In [[id]] [[G]] }}
   | formula1 = formula2 :: :: Equality
           {{ com equality }}
           {{ tex [[formula1]] = [[formula2]] }}
           {{ coq [[formula1]] = [[formula2]] }}
   | formula1 /\ formula2 :: :: And
           {{ com equality }}
           {{ tex [[formula1]] \land [[formula2]] }}
           {{ coq [[formula1]] /\ [[formula2]] }}
   | BAND  i . formula :: M :: BigAnd
           {{ com and fold on $[[i]]$ and $[[formula]]$ }}
           {{ tex \bigwedge_[[i]]. [[formula]] }}
           {{ coq Band [[i]] [[formula]] }}
   | formula1 INTR formula2 :: M :: Intersect
          % {{ com intersection of [[formula1]] [[formula2]] }}
           {{ tex [[formula1]] \cap [[formula2]] }}
           {{ coq set_inter ([[formula1]]) ([[formula2]]) }}
   | formula1 UNION formula2 :: M :: Union
          % {{ com union of [[formula1]] [[formula2]] }}
           {{ tex [[formula1]] \cup [[formula2]] }}
           {{ coq Intersection [[formula1]] [[formula2]] }}
   | formula1 SUB formula2 :: M :: Subset
          % {{ com [[formula1]] is subset of [[formula2]] }}
           {{ tex [[formula1]] \subseteq [[formula2]] }}
           {{ coq subset [[formula1]] [[formula2]] }}
   | formula1 INS formula2 :: M :: In
          % {{ com [[formula1]] is subset of [[formula2]] }}
           {{ tex [[formula1]] \in [[formula2]] }}
           {{ coq subset [[formula1]] [[formula2]] }}
   | G , P , O -> T :: :: TypeImpl
           {{ com impl }}
           {{ tex [[G]],[[P]],[[O]] \rightarrow [[T]] }}
           {{ coq [[G]] /\ [[P]] /\ [[O]] -> [[T]] }}
   | G , P , Q -> T :: :: QthingImpl
           {{ com impl }}
           {{ tex [[G]],[[P]],[[Q]] \rightarrow [[T]] }}
           {{ coq [[G]] /\ [[P]] /\ [[Q]] -> [[T]] }}
  | r1 , .. , rn :: :: RegL
  {{ com region list }}
  | phi :: :: Perm
  {{ com phi }}
  {{ tex [[phi]] }}
  {{ coq [[phi]] }}
  | om :: :: omegas
  {{ com om }}
  {{ tex [[om]] }}
  {{ coq [[om]] }}
  | O :: :: Perms {{ coq [[O]] }}
  | P :: :: Phi {{ coq [[P]] }}
  | Pst :: :: PhiStar {{ coq [[Pst]] }}
  | P [ r1 / r1' , .. , rn / rn' ] :: :: PhiRepl
  | T [ r1 / r1' , .. , rn / rn' ] :: :: TypeRepl
  % fixme
  | M [ rho1 / r1' , .. , rhon / rn' ] :: :: MemRepl {{ coq ([[M]])}}
  | M [[ T ]] :: :: MemSem
  | M [[ Q ]] :: :: MemQ
  | domain ( S ) :: :: Domain
  | M ( r ) :: :: MemLookup
  | G [ r1 / r1' , .. , rn / rn' ] :: :: TypeContextRepl
  | G [ e1 / T1 , .. , en / Tn ] :: :: TypeReplRepl
  | G :: :: TypeContF
  | G [ T [ r1 / r1' , .. , rn / rn' ] / id ] :: :: TypeContextElement
  | O [ r1 / r1' , .. , rn / rn' ] :: :: CompRepl
  | regions_of ( G , T ) :: :: RegionsOf2
  | regions_of ( G , T1, T2 ) :: :: RegionsOf3
  | rs :: :: RegionsForm
  | T :: :: TypeForm {{ coq [[T]] }}
  | fns :: :: Fns {{ coq [[fns]] }}
  | S :: :: Ss {{ coq [[S]] }}
  | C :: :: Cs {{ coq [[C]] }}
  | M :: :: Ms {{ coq [[M]] }}
  | e :: :: Exprs {{ coq [[e]] }}
  % | v :: :: Vs {{ coq [[v]] }}
  | E :: :: Es {{ coq [[E]] }}
  | L :: :: Ls {{ coq [[L]] }}
  | </ ei = li // i IN n      /> :: :: ListComp

terminals :: terminals_ ::=
  | EX  ::   :: exists          {{ tex \exists }}
  | ALL ::   :: forall          {{ tex \forall }}
  | in                         ::   :: in              {{ tex \in }}
  | om                      ::   :: omega           {{ tex \omega }}
  | phi                        ::   :: phi             {{ tex \phi }}
  | rho                        ::   :: rho             {{ tex \rho }}
  | \/                         ::   :: lor             {{ tex \lor }}
  | /\                         ::   :: land            {{ tex \land }}
  | ~                          ::   :: neg             {{ tex \neg }}
  %| <                         ::   :: lt            {{ tex < }}
  | *                         ::   :: sep {{ tex * }}
  | <=                         ::   :: leq            {{ tex \leq }}
  | -->                        ::   :: longrightarrow {{ tex \longrightarrow }}
  | ->                         ::   :: rightarrow     {{ tex \rightarrow }}
  | =>                         ::   :: Rightarrow     {{ tex \Rightarrow }}
  | \                          ::   :: lambda         {{ tex \lambda }}
  | |->                        ::   :: mapsto         {{ tex \mapsto }}
  | |-                         ::   :: vdash          {{ tex \vdash }}
  | emptyC                      ::   :: varnothingC     {{ tex \varnothing }}
  | emptyO                      ::   :: varnothingO     {{ tex \varnothing }}
  | emptyR                      ::   :: varnothingR     {{ tex \varnothing }}
  | emptyP                      ::   :: varnothingP     {{ tex \varnothing }}
  | *                          ::   :: times          {{ tex \times }}
  | <:                         ::   :: subtype        {{ tex <: }}
  | <                          ::   :: langle         {{ tex \langle }}
  | >                          ::   :: rangle         {{ tex \rangle }}
  | lt                         ::   :: lt             {{ tex < }}
  | \\                         ::   :: Downarrow      {{ tex \Downarrow }}
  | state                      ::   :: sigma          {{ tex \sigma }}
  | G                          ::   :: Gamma          {{ tex \Gamma }}
  | E                          ::   :: varepsilon        {{ tex \varepsilon }}
%  | ++                         ::   :: append            {{ tex \doubleplus }}

embed {{ coq
Definition reads (_:e) := E_PlaceHolder.
Definition writes (_:e) := E_PlaceHolder.
Definition reduces (_:e) := E_PlaceHolder.
Definition read (_:e) := E_PlaceHolder.
Definition reade (_:e) := E_PlaceHolder.
Definition write (_ _:e) :=  E_PlaceHolder.
Definition reduce (_:id) (_ _:e) := E_PlaceHolder.
Definition mark_coherence (_:E) (_:M) (_:iv) := E_PlaceHolder.
Definition new (_:T) := E_PlaceHolder.
Definition newcolor (_:r) := E_PlaceHolder.
Definition color (_ _:e) := E_PlaceHolder.
Definition upregion (_:e) (_:list_r) := E_PlaceHolder.
Definition downregion (_:e) (_:list_r) := E_PlaceHolder.
Definition partition (_:r) (_:e) (_:list_r) (_:e) := E_PlaceHolder.
Definition pack (_:e) (_:T) := E_PlaceHolder.
Definition unpack (_:e)  (_:id) (_:T) (_:e) := E_PlaceHolder.
Definition fncall (_:id) (_:list_r) (_:list_e) := E_PlaceHolder.
Definition fnlist (_:list_id_rr_ee) := E_PlaceHolder.
(* FIXME: make this type correctly *)
Definition IntOp (_ _:e) := E_PlaceHolder.
Definition Comp (_ _:e) := E_PlaceHolder.

(* how to do the substitution? *)
Fixpoint apply_mem (S:Clobber) E : Clobber :=
match S,rev E with
| S', [] => S'
| S', (em_ReadE _ _ _ _)::E' => apply_mem S' E'
| S', (em_WriteE l _ v _)::E' => (apply_mem S' E')  (* [v/l] *)
| S', (em_ReduceIdE l _ v _) :: E' => let S' := apply_mem S E' in
                                    S' (* S'[id(S'(l),v)/l]  *)
end.

(* what is mark coherence doing here? *) 
Fixpoint mark_coherence l Q taskid :=
match l,Q with
| [],Q' => []
| [op(l,c,v,t)]++E,Q' =>
  let c' =
      if rho == simult then
         simult
      else if rho == atomic then
           atomic
      else
           excl
  in
   [op(l,c',v,taskid)]++mark_coherence(E,Q') 
end.

mark coherence([], Q', taskid) = []
mark coherence([op(l, c, v, t)]++E, Q', taskid) = [op(l, c0, v, taskid)]++mark coherence(E, Q'),


}}

subrules
  v <:: e

embed {{ coq
Lemma eq_r: forall (x y : r), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_r : ott_coq_equality.

Lemma eq_list_r: forall (x y : list_r), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith. 
Defined.
Hint Resolve eq_list_r : ott_coq_equality.

Lemma eq_rr: forall (x y : rr), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith. 
Defined.
Hint Resolve eq_rr : ott_coq_equality.

Lemma eq_l: forall (x y : l), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_l : ott_coq_equality.

Lemma eq_om: forall (x y : om), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_om : ott_coq_equality.

Lemma eq_list_om: forall (x y : list_om), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_om : ott_coq_equality.


Lemma eq_Omega: forall (x y : Omega), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Omega : ott_coq_equality.

Lemma eq_Ost: forall (x y : Ost), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Ost : ott_coq_equality.

Lemma eq_rs: forall (x y : rs), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_rs : ott_coq_equality.

Lemma eq_phi: forall (x y : phi), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_phi : ott_coq_equality.

Lemma eq_list_phi: forall (x y : list_phi), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_phi : ott_coq_equality.

Lemma eq_P: forall (x y : P), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_P : ott_coq_equality.

Lemma eq_Pst: forall (x y : Pst), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Pst : ott_coq_equality.

Lemma eq_q: forall (x y : q), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_q : ott_coq_equality.

Lemma eq_list_q: forall (x y : list_q), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_q : ott_coq_equality.

Lemma eq_Q: forall (x y : Q), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Q : ott_coq_equality.

Lemma eq_M: forall (x y : M), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_M : ott_coq_equality.


Lemma eq_K: forall (x y : K), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_K : ott_coq_equality.

Lemma eq_H: forall (x y : H), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_H : ott_coq_equality.

Lemma eq_Clobber: forall (x y : Clobber), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_Clobber : ott_coq_equality.

Lemma eq_bv: forall (x y : bv), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_bv : ott_coq_equality.

Lemma eq_iv: forall (x y : iv), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_iv : ott_coq_equality.

Lemma eq_fresh: forall (x y : fresh), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_fresh : ott_coq_equality.

Lemma eq_id: forall (x y : id), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_id : ott_coq_equality.

Lemma eq_list_r_r: forall (x y : list_r_r), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_r_r : ott_coq_equality.


Fixpoint eq_T (x y : T): {x = y} + {x <> y}
with eq_list_T (x y : list_T): {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_T : ott_coq_equality.
Hint Resolve eq_list_T : ott_coq_equality.



Lemma eq_excl: forall (x y : excl), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_excl : ott_coq_equality.

Lemma eq_rho: forall (x y : rho), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_rho : ott_coq_equality.

Lemma eq_list_rho: forall (x y : list_rho), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_rho : ott_coq_equality.

Fixpoint eq_e (x y : e): {x = y} + {x <> y} 
with eq_list_e (x y : list_e): {x = y} + {x <> y}
with eq_ee (x y : ee): {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_e : ott_coq_equality.
Hint Resolve eq_list_e : ott_coq_equality.
Hint Resolve eq_ee : ott_coq_equality.

Lemma eq_list_e_T: forall (x y : list_e_T), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_e_T : ott_coq_equality.

Lemma eq_G: forall (x y : G), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_G : ott_coq_equality.

Lemma eq_list_e_e: forall (x y : list_e_e), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_e_e : ott_coq_equality.

Lemma eq_L: forall (x y : L), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_L : ott_coq_equality.

Lemma eq_E: forall (x y : E), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_E : ott_coq_equality.

Lemma eq_list_E: forall (x y : list_E), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_list_E : ott_coq_equality.

Lemma eq_fns: forall (x y : fns), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_fns : ott_coq_equality.

}}

defns
Jtype :: '' ::= 

defn
G , P , O |- e : T :: :: typing :: T_ {{ com Typing }} by

G,P,O |- e1 : T@(r1,..,rn) [[:type1checks]]
% so what to do here? 
% ALL i . reads(ri) in Pst [[:readperm]]
----------------- :: Read
G,P,O |- read(e1) : T

G,P,O |- e1 : T@(r1,..,rn) [[:type1checks]]
G,P,O |- e2 : T [[:type2checks]]
%ALL i . writes(ri) in Pst [[:writeperm]]
----------------- :: Write
G,P,O |- write(e1,e2) : T@(r1,..,rn)

% potentially need to do a fix here
% {(e1:T1),(e2:T2)},emptyP,emptyO -> T1 [[:impl]]
G,P,O |- e1 : T1@(r1,..,rn) [[:type1checks]]
G,P,O |- e2 : T2 [[:type2checks]]
% ALL i . reducesid(ri) in Pst [[:regionscanreduce]]
----------------- :: Reduce
G,P,O |- reduce(id,e1,e2) : T1@(r1,..,rn)


----------------- :: New
G,P,O |- new T@r : T@r

G,P,O |- e : T@(r1',..,rk') [[:renamedregion]]
%ALL i . EX j . ri' <= rj in Ost [[:alwaysaless]]
----------------- :: UpRgn 
G,P,O |- upregion(e1,r1,..,rn) : T@(r1,..,rn)

G,P,O |- e : T@(r1',..,rk') [[:haverenamed]]
----------------- :: DnRgn 
G,P,O |- downregion(e, r1,..,rn) : T@(r1,..,rn)

----------------- :: NewColor
G,P,O |- newcolor r : coloring(r)

G,P,O |- e1 : coloring(r) [[:type1checks]]
G,P,O |- e2 : T@r [[:type2checks]]
G,P,O |- e3 : int [[:type3checks]]
----------------- :: Color
G,P,O |- color(e1,e2,e3) : coloring(r)

G,P,O |- e1 : coloring(rp) [[:firstargcoloring]]
% (O' = O) /\ ((BAND i . ri <= rp) /\ (BAND j. ri * rj)) [[:everythingless]]
G,P,O' |- e2 : T [[:type2checks]]
%(({r1,..,rk}) INTR regions_of(G,T)) = emptyR [[:allregionsempty]]
----------------- :: Partition
G,P,O |- partition rp using e1 as r1,..,rk in e2: T

% is this necessary? need to think about this.
% T1 = EX r1',..,rk'.T2 WHERE O1 [[:existstype]]
% O1[r1/r1',..,rk/rk'] SUB O' [[:renamedsub]]
G,P,O |- e1 : T2[r1/r1',..,rk/rk'] [[:type1checks]]
----------------- :: Pack
G,P,O |- pack e1 as T1:T1
%G,P,O |- pack e1 as T1[r1,..,rk]:T1

% T1 = exists r1',..,rk'.T2 where O
% Is this necessary?
% T1 = EX r1',..,rk'.T2 WHERE O1 [[:typeexists]]
G,P,O |- e1 : T1 [[:type1checks]]
%G' = G[T2[r1/r1',..,rk/rk']/id] [[:renamedtypecontext]]
%O' = (O UNION O1[r1/r1',..,rk/rk']) [[:renamedpermissions]]
G',P,O' |- e2 : T3 [[:type2checks]]
%({r1,..,rk} INTR regions_of(G,T1,T3)) = emptyR [[:allregionsempty]]jjj
----------------- :: UnPack
G,P,O |- unpack e1 as id: T1 in e2:T3
%G,P,O |- unpack e1 as id: T1[r1,..,rk] in e2:T3

%{(e1:T1),..,(en:Tn)}
% G,P',Q' -> T [[:impl]]
% G,P,O |- e1 : T[r1/r1',..,rk/rk'] [[:typerename1check]]
%P'[r1/r1',..,rk/rk'] SUB Pst  [[:renamedsub]]
----------------- :: Call
G,P,O |- id[r1,..,rk](e1,..,en) : T

%Tr[r1/r1',..,rk/rk'] }}
% really there isn't much going on here.
% it's just a list of functions.
% and you are saying that. for each context the memory regions typecheck
%{{ for 1 <= i <= p,

% so this is actually a list of all these things.
% which means that I need to define a subset

%{(e1:T1),..,(en:Tn)}
%trip1,..,tripp
% G,P',Q' -> T [[:impl]]
% O1[r1/r1',..,rk/rk'] SUB O' [[:replsubset]]
% G = G[e1/T1,..,em/Tm] [[:renamedprog]]
----------------- :: Program
G,P,O |- {function id1 [r1,..,rk] (e1,..,em),..,function idn [r1,..,rk] (e1,..,em)} : T

defns
 Jop :: '' ::=

defn
M , L , H , S , C |- e |-> v , E  :: :: eval :: E {{ com Evaluation }} by

------ :: Va
M,L,H,S,C |- x |-> v, E

% M == r to rho mappings
% L == locals
% H == heaps and types
% E == dynamic memory trace
% S == clobber semantics
M,L,H,S,C |- e |-> l, E [[:prodvalue]]
S' = apply(S,E) [[:apply]]
~ (l INSI C) [[:memnotclobber]]
------------------------------------------------- :: Read1
M,L,H,S,C |- read(e) |-> v, E++[read(l,excl,v,0)]
%M,L,H,S,C |- read(e) |-> S'(l), E++[read(l,excl,v,0)] 

M,L,H,S,C |- e |-> l, E [[:prodvalue]]
l INSI C [[:memclobber]]
% S' = apply(S,E) [[:apply]]
------------------------------------------------- :: Read2
M,L,H,S,C |- read(e) |-> H(l), E++[read(l,excl,v,0)] 

%M,L,H,S,C |- e1 |-> l, E [[:prodvalue]]
%M,L,H,S,C |- e2 |-> l, E [[:prodvalue]]
%M,L,H,S,C |- e3 |-> l, E [[:prodvalue]]
% S' = apply(S,E) [[:apply]]
%------------------------------------------------- :: ReadE
%M,L,H,S,C |- read(e1, excl, e2, e3) |-> v, E

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
% S' = apply(S,E1) [[:apply]]
M,L,H,S',C |- e2 |-> v, E2 [[:prod2value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Write
M,L,H,S,C |- write(e1,e2) |-> l, E
%++[read(l,excl,v,0)] 

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
% S' = apply(S,E1) [[:apply]]
M,L,H,S',C |- e2 |-> v, E2 [[:prod2value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Reduce
M,L,H,S,C |- reduce(id,e1,e2) |-> l, E
%++[reduceid(l,excl,v,0)]

M,L,H,S,C |- l |-> v1, E1 [[:prod1value]]
% S' = apply(S,E1) [[:apply]]
M,L,H,S',C |- e1 |-> v2, E2 [[:prod2value]]
M,L,H,S',C |- e2 |-> v3, E3 [[:prod3value]]
M,L,H,S',C |- e3 |-> v4, E3 [[:prod3value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: ReduceId
M,L,H,S,C |- reduceid(l,e1,e2,e3) |-> v, E

----------------- :: Null
M,L,H,S,C |- null |-> null, []

% l INS M(r) [[:meminmem]]
%~(l INS domain(S)) [[:memindom]]
%H(l) = M[[T]] [[:heapeqmemtype]]

----------------- :: New
M,L,H,S,C |- new T@r |-> l, []

----------------- :: NullTrue
M,L,H,S,C |- null T@nullr |-> true, []

~(T@r = T@nullr)
----------------- :: NullFalse
M,L,H,S,C |- null T@r |-> false, []

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
l = null
----------------- :: IsNullTrue
M,L,H,S,C |- isnull(l) |-> true, []

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
~(l = null)
----------------- :: IsNullFalse
M,L,H,S,C |- isnull(l) |-> false, []

M,L,H,S,C |- e |-> v, E [[:prodvalue]]
------------------------------------------------- :: UpRgn
M,L,H,S,C |- upregion(e,r1,..,rn) |-> v, E

M,L,H,S,C |- e |-> v, E [[:prodvalue]]
% EX i. (l INS M(ri)) [[:inmem]]
------------------------------------------------- :: DnRgn1
M,L,H,S,C |- downregion(e,r1,..,rn) |-> l, E

M,L,H,S,C |- e |-> v, E [[:prodvalue]]
% ~(l INS M(ri)) [[:meminri]]
------------------------------------------------- :: DnRgn2
M,L,H,S,C |- downregion(e,r1,..,rn) |-> null, E

M,L,H,S,C |- e1 |-> l, E1 [[:prod1value]]
% S' = apply(S,E1) [[:apply1]]
M,L,H,S',C |- e2 |-> v, E2 [[:prod2value]]
% S'' = apply(S',E2) [[:apply2]]
M,L,H,S'',C |- e3 |-> v, E3 [[:prod3value]]
% need setbuilder notation here
% K' = {(l,v)} UNION {(li,vi)}
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Color
M,L,H,S,C |- color(e1,e2,e3) |-> K', E'


----------------- :: NewColor
M,L,H,S,C |- newcolor r |-> K,[]

M,L,H,S,C |- e1 |-> K, E1 [[:prod1value]]
% { rhoi ,
%M' = M[rho1/r1,..,rhok/rk] [[:memreplace]]
% S' = apply(S,E1) [[:apply]]
M,L,H,S',C |- e2 |-> v, E2 [[:prod2value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Partition
M,L,H,S,C |- partition rp using e1 as r1,..,rk in e2 |-> l, E'

M,L,H,S,C |- e1 |-> K, E1 [[:prod1value]]
% { rhoi ,
% v' = <<rho1,..,rhok,v>> [[:valismem]]
------------------------------------------------- :: Pack
M,L,H,S,C |- pack e1 as T1 |-> v', E
%M,L,H,S,C |- pack e1 as T1[r1,..,rk] |-> v', E

M,L,H,S,C |- e1 |-> <<rho1,..,rhok,v>>,E1 [[:prod1memval]]
%M' = M[rho1/r1,..,rhok/rk]  [[:memreplace]]
L'=L[v1/id] [[:lreplace]]
% S'=apply(S,E1) [[:apply]]
M',L',H,S',C |- e2 |-> v, E2 [[:prod2value]]
%valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- :: Unpack
M,L,H,S,C |- unpack e1 as id:T1 in e2 |-> v2, E'
%M,L,H,S,C |- unpack e1 as id:T1[r1,..,rk] in e2 |-> v2, E'


%M,L,H,S,C |- e1 |-> v1,E1 [[:prod1value]]
% S1 = apply(S,E1) [[:apply]]
%valid_interleave(S,C,E',E1,..,En) [[:validinterleave]]
% need a way of making a synonym here
%function id[r1',..,rk'](a1:T1,..,an:Tn),P',Q':Tr = en
% function id[r1',..,rk'](e1:T1,..,en:Tn),P',Q':Tr = en [[:funcdef]]
%+1
%M' = M[rho1/r1,..,rhok/rk] [[:memreplace]]
% fixme
L'=L[(e1,v1),..,(en,vn)] [[:memreplace]]
% S'=apply(S,E') [[:apply]]
%</ ei = li // i IN m      />  
%C' = C UNION {l: EX rho. l IN rho /\ (atomic(rho) IN M'[[Q']] \/ simult(rho) IN M'[[Q']])}
%M',L',H,S',C' |- en+1 |-> vn+1, En+1
%M',L',H,S',C' |- en |-> vn, En [[:nthvalue]]
%En+1'=mark_coherence(En+1,M'[[Q']],taskid)
% E'=mark_coherence(E,M'[[Q']],i) [[:makecoherence]]
%x = taskid fresh [[:freshid]]
% valid_interleave(S,C,E',E1,E2) [[:validinterleave]]
------------------------------------------------- ::  Call
M,L,H,S,C |- id[r1,..,rk](e1,..,en) |-> vn, E''
%M,L,H,S,C |- id[r1,..,rk](e1,..,en) |-> vn+1, E''


M,L,H,S,C |- e1 |-> v1,E1 [[:prod1value]]
M,L,H,S,C |- e2 |-> v2,E2 [[:prod2value]]
%v = v1+v2  [[:result]]  {{ coq [[v]] = (IntOp [[v1]] [[v2]]) }}
------------------------------------------------- :: IntOp 
M,L,H,S,C |- e1+e2 |-> v, E

M,L,H,S,C |- e1 |-> v1,E1 [[:prod1value]]
M,L,H,S,C |- e2 |-> v2,E2 [[:prod2value]]
%v = v1 lt v2 [[:result]]
------------------------------------------------- :: Comp 
M,L,H,S,C |- e1 lt e2 |-> v, E

% need to have a way of doing let bindings 
M,L,H,S,C |- e1 |-> v1,E1 [[:prod1value]]
% 
M,L,H,S,C |- e2 |-> v2,E2 [[:prod2value]]
L'=L[v1/id]
------------------------------------------------- :: Let 
M,L,H,S,C |- let id : T = e1 in e2 |-> v, E


M,L,H,S,C |- e1 |-> true,E1 [[:prod1value]]
M,L,H,S,C |- e2 |-> v,E1 [[:prod1value]]
------------------------------------------------- :: IfTrue
M,L,H,S,C |- if e1 then e2 else e3 |-> v, E

M,L,H,S,C |- e1 |-> false,E1 [[:prod1value]]
M,L,H,S,C |- e3 |-> v,E2 [[:prod2value]]
------------------------------------------------- :: IfFalse
M,L,H,S,C |- if e1 then e2 else e3 |-> v, E

% so you need to need to use it to add to the definitions.
% so what does a function def need to evaluate?
L'=L[ id[ r1 , .. , rn ]( e1 , .. , em )/id]
------------------------------------------------- :: FuncDef
M,L,H,S,C |- function id [ r1 , .. , rn ] ( e1 , .. , em ) |-> v, E

% need to make this work.
------------------------------------------------- :: FuncDefList
M,L,H,S,C |-  { function id1 rr1 ee1 , .. , function idn rrn een } |-> v, E

% constants
M,L,H,S,C |- e |-> v, E
-------------------------- :: TypedExpr
M,L,H,S,C |- e : T |-> v, E

-------------------- :: Place
M,L,H,S,C |- place |-> place, E

----------------------- :: bv 
M,L,H,S,C |- bv |-> bv, E

---------------------- :: iv 
M,L,H,S,C |- iv |-> iv, E

--------------------- :: Tuple
M,L,H,S,C |- <v1,v2> |-> <v1,v2>, E

------------------ :: NullLoc
M,L,H,S,C |- null |-> null, E

------------------ :: MemoryLoc
M,L,H,S,C |- l |-> l, E

---------------------- :: RegRelInst
M,L,H,S,C |-  <<rho1,..,rhon,v>> |->  <<rho1,..,rhon,v>>, E

---------------- :: HeapVal
M,L,H,S,C |- H |-> H, E

---------------- :: Kthing
M,L,H,S,C |- K |-> K, E

embed {{ coq
Notation "G , P , O |- e : T ":= (typing G P O e T) (no associativity, at level 99). 
Notation "M , L , H , S , C |- e |-> v , E" := (eval M L H S C e v E) (no associativity, at level 99).

(* need theorem to prove that all top level e there is a typing rule *)

Theorem preservation : forall (e5:e) (t:T) (E:E) (M:M) (L:L) (H:H) (S:Clobber) (C:C) (T:T),
    exists v,
      eval M L H S C e5 v E ->
      typing G_EmptyContext P_EmptyPriv O_EmptyConstraint e5 T  ->
      exists G P Omega T, typing G P Omega v T.
Proof.
  intros.
  eexists.
  intros.
  destruct e5; repeat (inversion H2;
  exists G_EmptyContext;
  exists  P_EmptyPriv;
  exists O_EmptyConstraint;
  exists T0;
  try (apply H2 || simpl;assumption || rewrite <- H9 at 1; rewrite H4;  assumption ) ).

  rewrite H5.
  assumption.
  rewrite H3.
  assumption.
Qed.
(*



Theorem paper1 :
 forall (e5:e) (t:T) (M:M) (H:H) (S:Clobber) (C:C) (T1 T2:T)  G P O,
     typing G P O e5 T1 /\ eval M L H S C e5 v E /\ map_consist M O /\ local_val_consit L H /\ store_consist S H ->
     result_consist v H M T  /\ memory_trace_consist E H /\ trace_has_privs E P

Lemma E :M P  <-> forall O,
      O = read l c v t -> exists r l, In l (M r) /\ In (reads r) Phi
      /\
      O = write l c v t -> exists r l, In l (M r) /\ In (writes r) Phi
      /\
      O = reduceid l c v t -> exists r l, In l (M r) /\ In (reducesid r) Phi


phi_A (op1 l1 c1 v1 t1) (op2 l2 c2 v2 t2) <->
      phi_A (op1 l1 c1 v1 t1) (op2 l2 c2 v2 t2) \/
      c1 = atomic /\ c2 = atomic /\ t1 <> t2

Theorem paper4: 
forall (l: list (e * P)) M L H S,
     M ~ O /\ L ~H M[[Gamma]] /\ S ~ H ->
       valid_interleaving

Theorem paper5 :
 forall (e5:e) (t:T) (M:M) (H:H) (S:Clobber) (C:C) (T1 T2:T)  G P O,
     (types1: typing G P O e1 T1)
     (types2: typing G P O e2 T1)
     (privsmatch: pound_M P1  P2)
     e1', e2' is a subexpression (represented by subtrees?)
     from E1' e1'
     from E2' e2'
     non interfering.


E :M Φ ⇔ ∀ ∈ E.
( = read(l, c, v, t) ⇒ ∃r, l ∈ M(r) ∧ reads(r) ∈ Φ) ∧
( = write(l, c, v, t) ⇒ ∃r, l ∈ M(r) ∧ writes(r) ∈ Φ) ∧
( = reduceid(l, c, v, t) ⇒ ∃r, l ∈ M(r) ∧ reducesid(r) ∈ Φ)
*)

Theorem progress : forall (e5:e) (t:T) (M:M) (H:H) (S:Clobber) (C:C) (T1 T2:T),
     exists E L v,
     typing G_EmptyContext P_EmptyPriv O_EmptyConstraint e5 T1  ->
       typing G_EmptyContext P_EmptyPriv O_EmptyConstraint v T2  ->
       eval M L H S C e5 v E.
Proof.
  intros.
  induction e5.
  - (* Va *)
  (*  eexists. *)
  exists E_NullE.
  exists L_Nil.
  exists E_PlaceHolder.
  intros.
  apply EVa.
  reflexivity.
  reflexivity.
  reflexivity.
  (* are memory locations some or none? *)
  - (* New *)
   (* eexists. *)
  exists (E_NullE).
  exists L_Nil.
  exists (E_MemoryLoc ML_NilLoc).
  intros.
  apply ENew.
  reflexivity.
  - (* NullFn *)
    destruct r5.
    * (* NullFn True *)
      (* eexists. *)

      exists (E_NullE).
      exists L_Nil.
      exists (E_Base1 bv_True).
      intros.
      apply ENullTrue.
      reflexivity.

    *   (* NullFn False *)
      (* eexists. *)
      exists (E_NullE).
      exists L_Nil.
      exists (E_Base1 bv_False).
      intros.
      apply ENullFalse.
      reflexivity.
      contradiction.
  - (* IsNull *)
    repeat eexists.
    intros.
    destruct e5; try (inversion H1).
  - (* UpRgn *)
    exists (E_NullE).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    apply EUpRgn.
    inversion H2.
    reflexivity.
    inversion H2.
    reflexivity.
    reflexivity.
  - (* DnRgn *)
    exists (E_NullE).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    inversion H2.
  - (* Read *)
    exists (E_Append E_NullE (E_ReadE (E_MemoryLoc ML_NilLoc) EX_Nil E_PlaceHolder E_Zero)).

    (* exists (E_NullE). *)
    exists L_Nil.
    repeat eexists.
    intros.
    (* how would I prove this in real life? should just work with rule2. *)
    (* the problem is that the inductive hypothesis is messed up *)
    apply ERead2.
    (* so we are proving that it always returns a memory location *)
    (* the inductive hypothesis should be that anything that typechecks for read
       so anything that any expression that can evaluate.
       Anything that doesn't type will contradict (If I do this right)
     *)
    destruct e5; inversion H2.
    reflexivity.
    inversion H2.
    reflexivity.
    (* FIXME: unimplemented *)
  - (* ReadE *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EReadE with (l5:=ML_NilLoc).
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
  - (* Write *) 
    exists (E_NullE).
    exists L_Nil.
    repeat eexists.
    intros.
    apply EWrite with (E1:=E_NullE) (Clobber':=S_Null) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE).
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    reflexivity.
    inversion H2.
    inversion H2.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Reduce *)
    exists (E_NullE).
    exists L_Nil.
    repeat eexists.
    intros.
    apply EReduce with (E1:=E_NullE) (Clobber':=S_Null) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE).
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    reflexivity.
    inversion H2.
    inversion H2.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Reduceid *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    repeat eexists.
    intros.
    apply EReduceId with (E1:=E_NullE) (Clobber':=S_Null) (v1:=(E_MemoryLoc ML_NilLoc)) (v2:=(E_MemoryLoc ML_NilLoc)) (v3:=(E_MemoryLoc ML_NilLoc)) (v4:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE) (E3:=E_NullE).
    inversion H1.
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    inversion H1.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* NewColor *)
    exists (E_NullE).
    exists L_Nil.
    Variable x0:K.
    exists (E_Kthing x0).
    intros.
    apply ENewColor.
    reflexivity.
  - (* Color *) 
    exists (E_NullE).
    exists L_Nil.
    exists (E_Kthing x0).
    intros.
    apply EColor with (E1:=E_NullE) (Clobber':=S_Null)  (Clobber'':=S_Null) (l5:=ML_NilLoc) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE) (E3:=E_NullE).
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    destruct e5_3; inversion H2.
    reflexivity.
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    destruct e5_3; inversion H2.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* IntOp *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EIntOp with  (E1:=E_NullE) (E2:=E_NullE) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    inversion H1.
    inversion H1.
    (* TODO: fill out IntOp *)
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Comp *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EComp with  (E1:=E_NullE) (E2:=E_NullE) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    inversion H1.
    inversion H1.
    (* TODO: fill out Comp *)
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  - (* Let *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply ELet with  (E1:=E_NullE) (E2:=E_NullE) (L':=L_Nil) (v1:=E_PlaceHolder) (v2:=E_PlaceHolder).
    destruct e5_1; inversion H1.
    destruct e5_1; inversion H2.
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
  (* TODO: fill out substition *)
    destruct id5; inversion H1.
  - (* If *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    destruct e5_1; inversion H1.
  - (* Call *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H2.
  - (* Partition *)
     exists (E_NullE).
    exists L_Nil.
    exists (E_MemoryLoc ML_NilLoc).
    intros.
    (* TODO: Get this unifying *)
    apply EPartition with (E1:=E_NullE) (Clobber':=S_Null) (v5:=(E_MemoryLoc ML_NilLoc)) (E2:=E_NullE) (K5:=K_Null) (p:=0).
    inversion H1.
    destruct e5_1; inversion H2.
    destruct e5_2; inversion H2.
    induction l0.
    simpl.
    inversion H2.
    simpl.
    inversion H2.
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* Pack *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EPack with (E1:=E_NullE) (K5:=K_Null).
    Variable xl : list_r.
    apply xl.
    destruct e5; inversion H2.
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* Unpack *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EUnpack with (r_rho_list:=Nil_list_r_rho) (v_5:=E_PlaceHolder) (E1:=E_NullE) (E2:=E_NullE)  (Clobber':=S_Null) (L':=L_Nil) (v1:=E_PlaceHolder) (M':=M_Nil).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
    (reflexivity || inversion H2).
  - (* FuncDef *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EFuncDef with (L':=L_Nil).
    reflexivity.
    reflexivity.
    reflexivity.
    reflexivity.
    (* TODO: list assumption needs cleanup *)
    induction l1.
    simpl.
    apply Forall_nil.
    apply Forall_cons.
    inversion H2.
    apply IHl1.
    inversion H1.
    (* TODO: really do the environment *)
    destruct id5; inversion H1.
  - (* FundDefList *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply EFuncDefList.
    reflexivity.
    reflexivity.
    reflexivity.
    induction l0.
    simpl.
    apply Forall_nil.
    apply Forall_cons.
    inversion H2.
    apply IHl0.
    inversion H2.
  - (* TypedExpr *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    apply ETypedExpr.
    reflexivity.
    inversion H1.
    reflexivity.
    reflexivity.
    destruct e5; inversion H2.
  - (* PlaceHolder *)
    (* TODO: remove when no longer necessary *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    inversion H1.
  - (* BoolVal *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    destruct bv5; inversion H1.
  - (* IntVal *)
    exists (E_NullE).
    exists L_Nil.
    exists E_PlaceHolder.
    intros.
    destruct iv5; inversion H1.
  -  (* Tuple *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    apply ETuple.
    reflexivity.
    inversion H1.
    inversion H1.
    reflexivity.
  - (* NullLoc *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* MemoryLoc *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* RegRelInst *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* HeapVal *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
    (* TODO: Understand this and name it correctly *)
  - (* Kthing *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* True *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* False *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* Zero *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
  - (* Succ *)
    exists (E_NullE).
    exists L_Nil.
    eexists.
    intros.
    inversion H1.
    Variable x1:E.
    Variable x2:L.
    Variable x3:e.
    Variable x4:l.
    Unshelve.
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
    repeat solve [(apply x1 || apply x2 || apply x3 || apply x4)].
Qed.
}}